{
    "language": "Solidity",
    "sources": {
        "./contracts/oracle/price/chainlink/ChainlinkFeedPriceOracle.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity =0.8.17;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@beehiveinnovation/rain-protocol/contracts/chainlink/LibChainlink.sol\";\n\nimport \"../IPriceOracle.sol\";\n\n/// @param feed The address of the underlying chainlink oracle.\n/// @param staleAfter The duration after which price data will be considered\n/// too stale for use and error.\nstruct ChainlinkFeedPriceOracleConfig {\n    address feed;\n    uint256 staleAfter;\n}\n\n/// @title ChainlinkFeedPriceOracle\n/// @notice Converts a single chainlink price oracle to an `IPriceOracle`.\n/// This involves:\n/// - Fetching latest round data from chainlink\n/// - Rejecting negative price values\n/// - Fetching decimals from chainlink\n/// - Rescaling chainlink price data to target decimals if required\ncontract ChainlinkFeedPriceOracle is IPriceOracle {\n    using SafeCast for int256;\n    using FixedPointMath for uint256;\n\n    /// Emitted upon deployment and construction of oracle\n    /// @param sender `msg.sender` that deploys the oracle.\n    /// @param config All config used to construct the contract.\n    event Construction(address sender, ChainlinkFeedPriceOracleConfig config);\n\n    /// Immutable copy of `ConstructionConfig.feed`.\n    address public immutable feed;\n\n    /// Immutable copy of `ConstructionConfig.staleAfter`.\n    uint256 public immutable staleAfter;\n\n    /// @param config_ Config required to interface with chainlink.\n    constructor(ChainlinkFeedPriceOracleConfig memory config_) {\n        feed = config_.feed;\n        staleAfter = config_.staleAfter;\n        emit Construction(msg.sender, config_);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function price() external view virtual returns (uint256) {\n        return LibChainlink.price(feed, staleAfter);\n    }\n}\n"
        },
        "./contracts/oracle/price/IPriceOracle.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity ^0.8.0;\n\n/// Simplified interface into a price oracle.\n/// The intention is that some more complex oracle interface such as chainlink\n/// `AggregatorV3Interface` is wrapped/adapted by a contract that implements\n/// `IPriceOracle` to produce a single final value.\n///\n/// Prices from an `IPriceOracle` MUST be:\n/// - The latest available data/value\n/// - Fresh enough or error if only too-stale data is available\n/// - Represented as positive uint values only or error\n/// - 18 decimal fixed point values representing a ratio (price) between \"base\"\n/// and \"quote\" token.\n///\n/// If for any reason the underlying oracle cannot produce an appropriate\n/// answer it MUST error rather than return inappropriate values. The ability\n/// to do so MAY be limited by upstream providers (e.g. Chainlink silently\n/// pausing price data during a heartbeat).\ninterface IPriceOracle {\n    /// Returns the current/latest price according to the oracle.\n    function price() external view returns (uint256);\n}\n"
        },
        "./contracts/oracle/price/chainlink/ChainlinkFeedPriceOracleFactory.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {Factory} from \"@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol\";\nimport \"./ChainlinkFeedPriceOracle.sol\";\n\n/// @title ChainlinkFeedPriceOracleFactory\n/// @notice Factory for creating and deploying `ChainlinkFeedPriceOracle`.\ncontract ChainlinkFeedPriceOracleFactory is Factory {\n    /// @inheritdoc Factory\n    function _createChild(bytes memory data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        // This is built directly with `new` instead of cloning as we're\n        // optimizing for use of cheap immutables at runtime rather than cheap\n        // deployments.\n        return\n            address(\n                new ChainlinkFeedPriceOracle(\n                    abi.decode(data_, (ChainlinkFeedPriceOracleConfig))\n                )\n            );\n    }\n\n    /// Typed wrapper for `createChild` with Source.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ configuration for the oracle.\n    /// @return New `ChainlinkFeedPriceOracle` child contract address.\n    function createChildTyped(ChainlinkFeedPriceOracleConfig memory config_)\n        external\n        returns (ChainlinkFeedPriceOracle)\n    {\n        return ChainlinkFeedPriceOracle(createChild(abi.encode(config_)));\n    }\n}\n"
        },
        "./contracts/oracle/price/TwoPriceOracle.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity =0.8.17;\n\nimport \"./IPriceOracle.sol\";\nimport \"@beehiveinnovation/rain-protocol/contracts/math/FixedPointMath.sol\";\n\n/// @param base The base price of the merged pair, will be the numerator.\n/// @param quote The quote price of the merged pair, will be the denominator.\nstruct TwoPriceOracleConfig {\n    address base;\n    address quote;\n}\n\n/// @title TwoPriceOracle\n/// Any time we have two price feeds that share a denominator we can calculate\n/// a single price by dividing them.\n///\n/// For example, an ETH/USD (base) and an XAU/USD (quote) price can be combined\n/// to a single ETH/XAU price as (ETH/USD) / (XAU/USD).\ncontract TwoPriceOracle is IPriceOracle {\n    using FixedPointMath for uint256;\n\n    /// Emitted upon deployment and construction.\n    event Construction(address sender, TwoPriceOracleConfig config);\n\n    /// As per `ConstructionConfig.base`.\n    IPriceOracle public immutable base;\n    /// As per `ConstructionConfig.quote`.\n    IPriceOracle public immutable quote;\n\n    /// @param config_ Config required to construct.\n    constructor(TwoPriceOracleConfig memory config_) {\n        base = IPriceOracle(config_.base);\n        quote = IPriceOracle(config_.quote);\n        emit Construction(msg.sender, config_);\n    }\n\n    /// Calculates the price as `base / quote`.\n    /// @inheritdoc IPriceOracle\n    function price() external view override returns (uint256) {\n        return base.price().fixedPointDiv(quote.price());\n    }\n}\n"
        },
        "./contracts/oracle/price/TwoPriceOracleFactory.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {Factory} from \"@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol\";\nimport \"./TwoPriceOracle.sol\";\n\n/// @title TwoPriceOracleFactory\n/// @notice Factory for creating and deploying `TwoPriceOracle`.\ncontract TwoPriceOracleFactory is Factory {\n    /// @inheritdoc Factory\n    function _createChild(bytes memory data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        // This is built directly with `new` instead of cloning as we're\n        // optimizing for use of cheap immutables at runtime rather than cheap\n        // deployments.\n        return\n            address(\n                new TwoPriceOracle(abi.decode(data_, (TwoPriceOracleConfig)))\n            );\n    }\n\n    /// Typed wrapper for `createChild` with Source.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ Config for the oracle.\n    /// @return New `ChainlinkFeedPriceOracle` child contract address.\n    function createChildTyped(TwoPriceOracleConfig memory config_)\n        external\n        returns (TwoPriceOracle)\n    {\n        return TwoPriceOracle(createChild(abi.encode(config_)));\n    }\n}\n"
        },
        "./contracts/test/TestChainlinkDataFeed.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Chainlink imports.\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nstruct RoundData {\n    int256 answer;\n    uint256 startedAt;\n    uint256 updatedAt;\n    uint80 answeredInRound;\n}\n\ncontract TestChainlinkDataFeed is AggregatorV3Interface {\n    uint8 private _decimals;\n    string private _description;\n    mapping(uint80 => RoundData) private _roundData;\n    uint80 private _latestRoundId;\n    uint256 private _version;\n\n    function setDecimals(uint8 decimals_) public {\n        _decimals = decimals_;\n    }\n\n    function setDescription(string memory description_) public {\n        _description = description_;\n    }\n\n    function setRoundData(uint80 roundId_, RoundData memory roundData_) public {\n        _roundData[roundId_] = roundData_;\n        // Treat this as the high water mark if appropriate.\n        if (roundId_ > _latestRoundId) {\n            _latestRoundId = roundId_;\n        }\n    }\n\n    function setVersion(uint256 version_) public {\n        _version = version_;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function description() public view override returns (string memory) {\n        return _description;\n    }\n\n    function getRoundData(uint80 roundId_)\n        public\n        view\n        override\n        returns (\n            uint80,\n            int256,\n            uint256,\n            uint256,\n            uint80\n        )\n    {\n        RoundData memory roundData_ = _roundData[roundId_];\n        return (\n            roundId_,\n            roundData_.answer,\n            roundData_.startedAt,\n            roundData_.updatedAt,\n            roundData_.answeredInRound\n        );\n    }\n\n    function latestRoundData()\n        public\n        view\n        override\n        returns (\n            uint80,\n            int256,\n            uint256,\n            uint256,\n            uint80\n        )\n    {\n        return getRoundData(_latestRoundId);\n    }\n\n    function version() public view override returns (uint256) {\n        return _version;\n    }\n}\n"
        },
        "./contracts/test/TestErc20.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {ERC20Upgradeable as ERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n// solhint-disable-next-line max-line-length\n\n/// @title Erc20Token\n/// A test token that can be used as a reserve asset.\n\ncontract TestErc20 is ERC20 {\n    /// Accounts to freeze during testing.\n\n    // Stables such as USDT and USDC commonly have 6 decimals.\n    uint256 public constant DECIMALS = 6;\n    // One _billion_ dollars .\n    uint256 public constant TOTAL_SUPPLY = 10**(DECIMALS + 9);\n\n    /// Define and mint the erc20 token.\n    constructor() initializer {\n        __ERC20_init(\"USD Classic\", \"USDCC\");\n        _mint(msg.sender, TOTAL_SUPPLY);\n    }\n}\n"
        },
        "./contracts/test/TestPriceOracle.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../oracle/price/IPriceOracle.sol\";\n\ncontract TestPriceOracle is IPriceOracle {\n    uint256 private _price;\n\n    function setPrice(uint256 price_) public {\n        _price = price_;\n    }\n\n    function price() external view override returns (uint256) {\n        return _price;\n    }\n}\n"
        },
        "./contracts/test/TierV2Test.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {ReadWriteTier} from \"@beehiveinnovation/rain-protocol/contracts/test/tier/TierV2/ReadWriteTier.sol\";\n"
        },
        "./contracts/vault/offchainAsset/OffchainAssetReceiptVault.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity =0.8.17;\n\nimport {ReceiptVaultConfig, VaultConfig, ReceiptVault} from \"../receipt/ReceiptVault.sol\";\nimport {AccessControlUpgradeable as AccessControl} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"../receipt/IReceipt.sol\";\nimport \"@beehiveinnovation/rain-protocol/contracts/tier/ITierV2.sol\";\n\n/// All data required to configure an offchain asset vault except the receipt.\n/// Typically the factory should build a receipt contract and transfer ownership\n/// to the vault atomically during initialization so there is no opportunity for\n/// an attacker to corrupt the initialzation process.\n/// @param admin as per `OffchainAssetReceiptVaultConfig`.\n/// @param vaultConfig MUST be used by the factory to build a\n/// `ReceiptVaultConfig` once the receipt address is known and ownership has been\n/// transferred to the vault contract (before initialization).\nstruct OffchainAssetVaultConfig {\n    address admin;\n    VaultConfig vaultConfig;\n}\n\n/// All data required to construct `CertifiedAssetConnect`.\n/// @param admin The initial admin has ALL ROLES. It is up to the admin to\n/// appropriately delegate and renounce roles or to be a smart contract with\n/// formal governance processes. In general a single EOA holding all admin roles\n/// is completely insecure and counterproductive as it allows a single address\n/// to both mint and audit assets (and many other things).\n/// @param receiptConfig Forwarded to ReceiptVault.\nstruct OffchainAssetReceiptVaultConfig {\n    address admin;\n    ReceiptVaultConfig receiptVaultConfig;\n}\n\n/// @title OffchainAssetReceiptVault\n/// @notice Enables curators of offchain assets to create a token that they can\n/// arbitrage offchain assets against onchain assets. This allows them to\n/// maintain a peg between offchain and onchain markets.\n///\n/// At a high level this works because the custodian can always profitably trade\n/// the peg against offchain markets in both directions.\n///\n/// Price is higher onchain: Custodian can buy/produce assets offchain and mint\n/// tokens then sell the tokens for more than the assets would sell for offchain\n/// thus making a profit. The sale of the tokens brings the onchain price down.\n/// Price is higher offchain: Custodian can sell assets offchain and\n/// buyback+burn tokens onchain for less than the offchain sale, thus making a\n/// profit. The token purchase brings the onchain price up.\n///\n/// In contrast to pure algorithmic tokens and sentiment based stablecoins, a\n/// competent custodian can profit \"infinitely\" to maintain the peg no matter\n/// how badly the peg breaks. As long as every token is fully collateralised by\n/// liquid offchain assets, tokens can be profitably bought and burned by the\n/// custodian all the way to 0 token supply.\n///\n/// This model is contingent on existing onchain and offchain liquidity\n/// and the custodian being competent. These requirements are non-trivial. There\n/// are far more incompetent and malicious custodians than competent ones. Only\n/// so many bars of gold can fit in a vault, and only so many trees that can\n/// live in a forest.\n///\n/// This contract does not attempt to solve for liquidity and trustworthyness,\n/// it only seeks to provide baseline functionality that a competent custodian\n/// will need to tackle the problem. The implementation provides:\n///\n/// - ReceiptVault base that allows a transparent onchain/offchain audit history\n/// - Certifier role that allows for audits of offchain assets that can fail\n/// - KYC/membership lists that can restrict who can hold/transfer assets\n/// - Ability to comply with sanctions/regulators by confiscating assets\n/// - ERC20 shares in the vault that can be traded minted/burned to track a peg\n/// - ERC4626 compliant vault interface (inherited from ReceiptVault)\n/// - Fine grained standard Open Zeppelin access control for all system roles\ncontract OffchainAssetReceiptVault is ReceiptVault, AccessControl {\n    /// Contract has initialized.\n    /// @param caller The `msg.sender` constructing the contract.\n    /// @param config All initialization config.\n    event OffchainAssetVaultInitialized(\n        address caller,\n        OffchainAssetReceiptVaultConfig config\n    );\n\n    /// A new certification time has been set.\n    /// @param caller The certifier setting the new time.\n    /// @param until The time the system is certified until. Normally this will\n    /// be a future time but certifiers MAY set it to a time in the past which\n    /// will immediately freeze all transfers.\n    /// @param data The certifier MAY provide additional supporting data such\n    /// as an auditor's report/comments etc.\n    event Certify(address caller, uint256 until, bytes data);\n\n    /// Shares have been confiscated from a user who is not currently meeting\n    /// the ERC20 tier contract minimum requirements.\n    /// @param caller The confiscator who is confiscating the shares.\n    /// @param confiscatee The user who had their shares confiscated.\n    /// @param confiscated The amount of shares that were confiscated.\n    event ConfiscateShares(\n        address caller,\n        address confiscatee,\n        uint256 confiscated\n    );\n\n    /// A receipt has been confiscated from a user who is not currently meeting\n    /// the ERC1155 tier contract minimum requirements.\n    /// @param caller The confiscator who is confiscating the receipt.\n    /// @param confiscatee The user who had their receipt confiscated.\n    /// @param id The receipt ID that was confiscated.\n    /// @param confiscated The amount of the receipt that was confiscated.\n    event ConfiscateReceipt(\n        address caller,\n        address confiscatee,\n        uint256 id,\n        uint256 confiscated\n    );\n\n    /// A new ERC20 tier contract has been set.\n    /// @param caller `msg.sender` who set the new tier contract.\n    /// @param tier New tier contract used for all ERC20 transfers and\n    /// confiscations.\n    /// @param minimumTier Minimum tier that a user must hold to be eligible\n    /// to send/receive/hold shares and be immune to share confiscations.\n    /// @param context OPTIONAL additional context to pass to ITierV2 calls.\n    event SetERC20Tier(\n        address caller,\n        address tier,\n        uint256 minimumTier,\n        uint256[] context\n    );\n\n    /// A new ERC1155 tier contract has been set.\n    /// @param caller `msg.sender` who set the new tier contract.\n    /// @param tier New tier contract used for all ERC1155 transfers and\n    /// confiscations.\n    /// @param minimumTier Minimum tier that a user must hold to be eligible\n    /// to send/receive/hold receipts and be immune to receipt confiscations.\n    /// @param context OPTIONAL additional context to pass to ITierV2 calls.\n    event SetERC1155Tier(\n        address caller,\n        address tier,\n        uint256 minimumTier,\n        uint256[] context\n    );\n\n    bytes32 public constant DEPOSITOR = keccak256(\"DEPOSITOR\");\n    bytes32 public constant DEPOSITOR_ADMIN = keccak256(\"DEPOSITOR_ADMIN\");\n\n    bytes32 public constant WITHDRAWER = keccak256(\"WITHDRAWER\");\n    bytes32 public constant WITHDRAWER_ADMIN = keccak256(\"WITHDRAWER_ADMIN\");\n\n    bytes32 public constant CERTIFIER = keccak256(\"CERTIFIER\");\n    bytes32 public constant CERTIFIER_ADMIN = keccak256(\"CERTIFIER_ADMIN\");\n\n    bytes32 public constant HANDLER = keccak256(\"HANDLER\");\n    bytes32 public constant HANDLER_ADMIN = keccak256(\"HANDLER_ADMIN\");\n\n    bytes32 public constant ERC20TIERER = keccak256(\"ERC20TIERER\");\n    bytes32 public constant ERC20TIERER_ADMIN = keccak256(\"ERC20TIERER_ADMIN\");\n\n    bytes32 public constant ERC1155TIERER = keccak256(\"ERC1155TIERER\");\n    bytes32 public constant ERC1155TIERER_ADMIN =\n        keccak256(\"ERC1155TIERER_ADMIN\");\n\n    bytes32 public constant ERC20SNAPSHOTTER = keccak256(\"ERC20SNAPSHOTTER\");\n    bytes32 public constant ERC20SNAPSHOTTER_ADMIN =\n        keccak256(\"ERC20SNAPSHOTTER_ADMIN\");\n\n    bytes32 public constant CONFISCATOR = keccak256(\"CONFISCATOR\");\n    bytes32 public constant CONFISCATOR_ADMIN = keccak256(\"CONFISCATOR_ADMIN\");\n\n    uint256 private highwaterId;\n\n    uint32 private certifiedUntil;\n\n    uint8 private erc20MinimumTier;\n    ITierV2 private erc20Tier;\n    uint256[] private erc20TierContext;\n\n    uint8 private erc1155MinimumTier;\n    ITierV2 private erc1155Tier;\n    uint256[] private erc1155TierContext;\n\n    function initialize(OffchainAssetReceiptVaultConfig memory config_)\n        external\n        initializer\n    {\n        __ReceiptVault_init(config_.receiptVaultConfig);\n        __AccessControl_init();\n\n        // There is no asset, the asset is offchain.\n        require(\n            config_.receiptVaultConfig.vaultConfig.asset == address(0),\n            \"NONZERO_ASSET\"\n        );\n\n        _setRoleAdmin(DEPOSITOR_ADMIN, DEPOSITOR_ADMIN);\n        _setRoleAdmin(DEPOSITOR, DEPOSITOR_ADMIN);\n\n        _setRoleAdmin(WITHDRAWER_ADMIN, WITHDRAWER_ADMIN);\n        _setRoleAdmin(WITHDRAWER, WITHDRAWER_ADMIN);\n\n        _setRoleAdmin(CERTIFIER_ADMIN, CERTIFIER_ADMIN);\n        _setRoleAdmin(CERTIFIER, CERTIFIER_ADMIN);\n\n        _setRoleAdmin(HANDLER_ADMIN, HANDLER_ADMIN);\n        _setRoleAdmin(HANDLER, HANDLER_ADMIN);\n\n        _setRoleAdmin(ERC20TIERER_ADMIN, ERC20TIERER_ADMIN);\n        _setRoleAdmin(ERC20TIERER, ERC20TIERER_ADMIN);\n\n        _setRoleAdmin(ERC1155TIERER_ADMIN, ERC1155TIERER_ADMIN);\n        _setRoleAdmin(ERC1155TIERER, ERC1155TIERER_ADMIN);\n\n        _setRoleAdmin(ERC20SNAPSHOTTER_ADMIN, ERC20SNAPSHOTTER_ADMIN);\n        _setRoleAdmin(ERC20SNAPSHOTTER, ERC20SNAPSHOTTER_ADMIN);\n\n        _setRoleAdmin(CONFISCATOR_ADMIN, CONFISCATOR_ADMIN);\n        _setRoleAdmin(CONFISCATOR, CONFISCATOR_ADMIN);\n\n        _grantRole(DEPOSITOR_ADMIN, config_.admin);\n        _grantRole(WITHDRAWER_ADMIN, config_.admin);\n        _grantRole(CERTIFIER_ADMIN, config_.admin);\n        _grantRole(HANDLER_ADMIN, config_.admin);\n        _grantRole(ERC20TIERER_ADMIN, config_.admin);\n        _grantRole(ERC1155TIERER_ADMIN, config_.admin);\n        _grantRole(ERC20SNAPSHOTTER_ADMIN, config_.admin);\n        _grantRole(CONFISCATOR_ADMIN, config_.admin);\n\n        emit OffchainAssetVaultInitialized(msg.sender, config_);\n    }\n\n    function _beforeDeposit(\n        uint256,\n        address,\n        uint256,\n        uint256\n    ) internal view override {\n        require(hasRole(DEPOSITOR, msg.sender), \"NOT_DEPOSITOR\");\n    }\n\n    function _afterWithdraw(\n        uint256,\n        address,\n        address owner_,\n        uint256,\n        uint256\n    ) internal view override {\n        require(hasRole(WITHDRAWER, owner_), \"NOT_WITHDRAWER\");\n    }\n\n    /// Shares total supply is 1:1 with offchain assets.\n    /// Assets aren't real so only way to report this is to return the total\n    /// supply of shares.\n    /// @inheritdoc ReceiptVault\n    function totalAssets()\n        external\n        view\n        override\n        returns (uint256 totalManagedAssets_)\n    {\n        totalManagedAssets_ = totalSupply();\n    }\n\n    function _shareRatio(address depositor_, address)\n        internal\n        view\n        override\n        returns (uint256 shareRatio_)\n    {\n        shareRatio_ = hasRole(DEPOSITOR, depositor_) ? _shareRatio() : 0;\n    }\n\n    /// Offchain assets are always deposited 1:1 with shares.\n    /// @inheritdoc ReceiptVault\n    function previewDeposit(uint256 assets_)\n        external\n        view\n        override\n        returns (uint256 shares_)\n    {\n        shares_ = hasRole(DEPOSITOR, msg.sender) ? assets_ : 0;\n    }\n\n    function previewWithdraw(uint256 assets_, uint256 id_)\n        public\n        view\n        override\n        returns (uint256 shares_)\n    {\n        shares_ = hasRole(WITHDRAWER, msg.sender)\n            ? super.previewWithdraw(assets_, id_)\n            : 0;\n    }\n\n    function previewMint(uint256 shares_)\n        public\n        view\n        override\n        returns (uint256 assets_)\n    {\n        assets_ = hasRole(DEPOSITOR, msg.sender)\n            ? super.previewMint(shares_)\n            : 0;\n    }\n\n    function previewRedeem(uint256 shares_, uint256 id_)\n        public\n        view\n        override\n        returns (uint256 assets_)\n    {\n        assets_ = hasRole(WITHDRAWER, msg.sender)\n            ? super.previewRedeem(shares_, id_)\n            : 0;\n    }\n\n    function _nextId() internal override returns (uint256 id_) {\n        id_ = highwaterId + 1;\n        highwaterId = id_;\n    }\n\n    function authorizeReceiptInformation(uint256 id_, bytes memory)\n        external\n        view\n        virtual\n        override\n    {\n        // Only receipt holders and certifiers can assert things about offchain\n        // assets.\n        require(\n            IReceipt(_receipt).balanceOf(msg.sender, id_) > 0 ||\n                hasRole(CERTIFIER, msg.sender),\n            \"ASSET_INFORMATION_AUTH\"\n        );\n    }\n\n    /// Receipt holders who are also depositors can increase the deposit amount\n    /// for the existing id of this receipt. It is STRONGLY RECOMMENDED the\n    /// redepositor also provides data to be forwarded to asset information to\n    /// justify the additional deposit. New offchain assets MUST NOT redeposit\n    /// under existing IDs, deposit under a new id instead.\n    /// @param assets_ As per IERC4626 `deposit`.\n    /// @param receiver_ As per IERC4626 `deposit`.\n    /// @param id_ The existing receipt to despoit additional assets under. Will\n    /// mint new ERC20 shares and also increase the held receipt amount 1:1.\n    /// @param receiptInformation_ Forwarded to receipt mint and\n    /// `receiptInformation`.\n    function redeposit(\n        uint256 assets_,\n        address receiver_,\n        uint256 id_,\n        bytes calldata receiptInformation_\n    ) external returns (uint256 shares_) {\n        // This is stricter than the standard \"or certifier\" check.\n        require(\n            IReceipt(_receipt).balanceOf(msg.sender, id_) > 0,\n            \"NOT_RECEIPT_HOLDER\"\n        );\n        _deposit(\n            assets_,\n            receiver_,\n            _shareRatio(msg.sender, receiver_),\n            id_,\n            receiptInformation_\n        );\n        shares_ = assets_;\n    }\n\n    function snapshot() external onlyRole(ERC20SNAPSHOTTER) returns (uint256) {\n        return _snapshot();\n    }\n\n    /// @param tier_ `ITier` contract to check reports from. MAY be `0` to\n    /// disable report checking.\n    /// @param minimumTier_ The minimum tier to be held according to `tier_`.\n    function setERC20Tier(\n        address tier_,\n        uint8 minimumTier_,\n        uint256[] calldata context_\n    ) external onlyRole(ERC20TIERER) {\n        erc20Tier = ITierV2(tier_);\n        erc20MinimumTier = minimumTier_;\n        erc20TierContext = context_;\n        emit SetERC20Tier(msg.sender, tier_, minimumTier_, context_);\n    }\n\n    /// @param tier_ `ITier` contract to check reports from. MAY be `0` to\n    /// disable report checking.\n    /// @param minimumTier_ The minimum tier to be held according to `tier_`.\n    function setERC1155Tier(\n        address tier_,\n        uint8 minimumTier_,\n        uint256[] calldata context_\n    ) external onlyRole(ERC1155TIERER) {\n        erc1155Tier = ITierV2(tier_);\n        erc1155MinimumTier = minimumTier_;\n        erc1155TierContext = context_;\n        emit SetERC1155Tier(msg.sender, tier_, minimumTier_, context_);\n    }\n\n    function certify(\n        uint32 until_,\n        bytes calldata data_,\n        bool forceUntil_\n    ) external onlyRole(CERTIFIER) {\n        // A certifier can set `forceUntil_` to true to force a _decrease_ in\n        // the `certifiedUntil` time, which is unusual but MAY need to be done\n        // in the case of rectifying a prior mistake.\n        if (forceUntil_ || until_ > certifiedUntil) {\n            certifiedUntil = until_;\n        }\n        emit Certify(msg.sender, until_, data_);\n    }\n\n    function enforceValidTransfer(\n        ITierV2 tier_,\n        uint256 minimumTier_,\n        uint256[] memory tierContext_,\n        address from_,\n        address to_\n    ) internal view {\n        // Handlers can ALWAYS send and receive funds.\n        // Handlers bypass BOTH the timestamp on certification AND tier based\n        // restriction.\n        if (hasRole(HANDLER, from_) || hasRole(HANDLER, to_)) {\n            return;\n        }\n\n        // Minting and burning is always allowed as it is controlled via. RBAC\n        // separately to the tier contracts. Minting and burning is ALSO valid\n        // after the certification expires as it is likely the only way to\n        // repair the system and bring it back to a certifiable state.\n        if (from_ == address(0) || to_ == address(0)) {\n            return;\n        }\n\n        // Confiscation is always allowed as it likely represents some kind of\n        // regulatory/legal requirement. It may also be required to satisfy\n        // certification requirements.\n        if (hasRole(CONFISCATOR, to_)) {\n            return;\n        }\n\n        // Everyone else can only transfer while the certification is valid.\n        //solhint-disable-next-line not-rely-on-time\n        require(block.timestamp <= certifiedUntil, \"CERTIFICATION_EXPIRED\");\n\n        // If there is a tier contract we enforce it.\n        if (address(tier_) != address(0) && minimumTier_ > 0) {\n            // The sender must have a valid tier.\n            require(\n                block.timestamp >=\n                    tier_.reportTimeForTier(from_, minimumTier_, tierContext_),\n                \"SENDER_TIER\"\n            );\n            // The recipient must have a valid tier.\n            require(\n                block.timestamp >=\n                    tier_.reportTimeForTier(to_, minimumTier_, tierContext_),\n                \"RECIPIENT_TIER\"\n            );\n        }\n    }\n\n    // @inheritdoc ERC20\n    function _beforeTokenTransfer(\n        address from_,\n        address to_,\n        uint256\n    ) internal view override {\n        enforceValidTransfer(\n            erc20Tier,\n            erc20MinimumTier,\n            erc20TierContext,\n            from_,\n            to_\n        );\n    }\n\n    function authorizeReceiptTransfer(address from_, address to_)\n        external\n        view\n        virtual\n        override\n    {\n        enforceValidTransfer(\n            erc1155Tier,\n            erc1155MinimumTier,\n            erc1155TierContext,\n            from_,\n            to_\n        );\n    }\n\n    function confiscate(address confiscatee_)\n        external\n        nonReentrant\n        onlyRole(CONFISCATOR)\n        returns (uint256 confiscated_)\n    {\n        if (\n            address(erc20Tier) == address(0) ||\n            block.timestamp <\n            erc20Tier.reportTimeForTier(\n                confiscatee_,\n                erc20MinimumTier,\n                erc20TierContext\n            )\n        ) {\n            confiscated_ = balanceOf(confiscatee_);\n            if (confiscated_ > 0) {\n                _transfer(confiscatee_, msg.sender, confiscated_);\n            }\n        }\n        emit ConfiscateShares(msg.sender, confiscatee_, confiscated_);\n    }\n\n    function confiscate(address confiscatee_, uint256 id_)\n        external\n        nonReentrant\n        onlyRole(CONFISCATOR)\n        returns (uint256 confiscated_)\n    {\n        if (\n            address(erc1155Tier) == address(0) ||\n            block.timestamp <\n            erc1155Tier.reportTimeForTier(\n                confiscatee_,\n                erc1155MinimumTier,\n                erc1155TierContext\n            )\n        ) {\n            IReceipt receipt_ = IReceipt(_receipt);\n            confiscated_ = IReceipt(receipt_).balanceOf(confiscatee_, id_);\n            if (confiscated_ > 0) {\n                receipt_.ownerTransferFrom(\n                    confiscatee_,\n                    msg.sender,\n                    id_,\n                    confiscated_,\n                    \"\"\n                );\n            }\n        }\n        emit ConfiscateReceipt(msg.sender, confiscatee_, id_, confiscated_);\n    }\n}\n"
        },
        "./contracts/vault/receipt/ReceiptVault.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity =0.8.17;\n\nimport {ERC20Upgradeable as ERC20, ERC20SnapshotUpgradeable as ERC20Snapshot} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\nimport {IERC4626Upgradeable as IERC4626} from \"@openzeppelin/contracts-upgradeable/interfaces/IERC4626Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {MulticallUpgradeable as Multicall} from \"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\";\nimport \"./IReceipt.sol\";\nimport \"@beehiveinnovation/rain-protocol/contracts/math/FixedPointMath.sol\";\nimport \"./IReceiptOwner.sol\";\n\nstruct VaultConfig {\n    address asset;\n    string name;\n    string symbol;\n}\n\nstruct ReceiptVaultConfig {\n    address receipt;\n    VaultConfig vaultConfig;\n}\n\ncontract ReceiptVault is\n    IReceiptOwner,\n    Multicall,\n    ReentrancyGuard,\n    ERC20Snapshot,\n    IERC4626\n{\n    using FixedPointMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// Similar to IERC4626 deposit but with receipt ID and information.\n    /// @param caller As per `IERC4626.Deposit`.\n    /// @param receiver As per `IERC4626.Deposit`.\n    /// @param assets As per `IERC4626.Deposit`.\n    /// @param shares As per `IERC4626.Deposit`.\n    /// @param id As per `IERC1155.TransferSingle`.\n    /// @param receiptInformation As per `ReceiptInformation`.\n    event DepositWithReceipt(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares,\n        uint256 id,\n        bytes receiptInformation\n    );\n\n    /// Similar to IERC4626 withdraw but with receipt ID.\n    /// @param caller As per `IERC4626.Withdraw`.\n    /// @param receiver As per `IERC4626.Withdraw`.\n    /// @param owner As per `IERC4626.Withdraw`.\n    /// @param assets As per `IERC4626.Withdraw`.\n    /// @param shares As per `IERC4626.Withdraw`.\n    /// @param id As per `IERC1155.TransferSingle`.\n    event WithdrawWithReceipt(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares,\n        uint256 id\n    );\n\n    address internal _asset;\n    address internal _receipt;\n\n    /// Users MAY OPTIONALLY set minimum share ratios for 4626 deposits.\n    /// Alternatively they MAY avoid the gas cost of modifying storage and call\n    /// the non-standard equivalent functions that take a minimum share ratio\n    /// parameter.\n    mapping(address => uint256) public minShareRatios;\n\n    /// Users MAY OPTIONALLY set the receipt ID they want to withdraw as a\n    /// two step workflow and call the 4626 standard withdraw functions.\n    /// Alternatively they MAY avoid the gas cost of modifying storage and call\n    /// the non-standard equivalent functions that take a ID parameter.\n    mapping(address => uint256) public withdrawIds;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function __ReceiptVault_init(ReceiptVaultConfig memory config_)\n        internal\n        virtual\n    {\n        __Multicall_init();\n        __ReentrancyGuard_init();\n        __ERC20_init(config_.vaultConfig.name, config_.vaultConfig.symbol);\n        _asset = config_.vaultConfig.asset;\n        _receipt = config_.receipt;\n    }\n\n    /// @inheritdoc IReceiptOwner\n    function authorizeReceiptTransfer(address, address)\n        external\n        view\n        virtual\n    // solhint-disable-next-line no-empty-blocks\n\n    {\n        // Authorize all receipt transfers by default.\n    }\n\n    /// @inheritdoc IReceiptOwner\n    function authorizeReceiptInformation(uint256 id_, bytes memory data_)\n        external\n        view\n        virtual\n    // solhint-disable-next-line no-empty-blocks\n    {\n        // Authorize all receipt information by default.\n    }\n\n    /// Calculate how many shares_ will be minted in return for assets_.\n    /// @param assets_ Amount of assets being deposited.\n    /// @param shareRatio_ The ratio of shares to assets to deposit against.\n    /// @param minShareRatio_ The minimum share ratio required by the\n    /// depositor. Will error if `shareRatio_` is less than `minShareRatio_`.\n    /// @return shares_ Amount of shares to mint for this deposit.\n    function _calculateDeposit(\n        uint256 assets_,\n        uint256 shareRatio_,\n        uint256 minShareRatio_\n    ) internal pure returns (uint256 shares_) {\n        require(shareRatio_ >= minShareRatio_, \"MIN_SHARE_RATIO\");\n        // IRC4626:\n        // If (1) it’s calculating how many shares to issue to a user for a\n        // certain amount of the underlying tokens they provide, it should\n        // round down.\n        shares_ = assets_.fixedPointMul(shareRatio_);\n    }\n\n    /// Calculate how many assets_ are needed to mint shares_.\n    /// @param shares_ Amount of shares desired to be minted.\n    /// @param shareRatio_ The ratio shares are minted at per asset.\n    /// @param minShareRatio_ The minimum ratio required by the minter. Will\n    /// error if `shareRatio_` is less than `minShareRatio_`.\n    /// @return assets_ Amount of assets that must be deposited for this mint.\n    function _calculateMint(\n        uint256 shares_,\n        uint256 shareRatio_,\n        uint256 minShareRatio_\n    ) internal pure returns (uint256 assets_) {\n        require(shareRatio_ >= minShareRatio_, \"MIN_SHARE_RATIO\");\n        // IERC4626:\n        // If (2) it’s calculating the amount of underlying tokens a user has\n        // to provide to receive a certain amount of shares, it should\n        // round up.\n        assets_ = shares_.fixedPointDiv(shareRatio_) + 1;\n    }\n\n    /// Calculate how many shares_ to burn to withdraw assets_.\n    /// @param assets_ Amount of assets being withdrawn.\n    /// @param shareRatio_ Ratio of shares to assets to withdraw against.\n    /// @return shares_ Amount of shares to burn for this withdrawal.\n    function _calculateWithdraw(uint256 assets_, uint256 shareRatio_)\n        internal\n        pure\n        returns (uint256 shares_)\n    {\n        // IERC4626:\n        // If (1) it’s calculating the amount of shares a user has to supply to\n        // receive a given amount of the underlying tokens, it should round up.\n        shares_ = assets_.fixedPointMul(shareRatio_) + 1;\n    }\n\n    /// Calculate how many assets_ to withdraw for burning shares_.\n    /// @param shares_ Amount of shares being burned for redemption.\n    /// @param shareRatio_ Ratio of shares to assets being redeemed against.\n    /// @return assets_ Amount of assets that will be redeemed for the given\n    /// shares.\n    function _calculateRedeem(uint256 shares_, uint256 shareRatio_)\n        internal\n        pure\n        returns (uint256 assets_)\n    {\n        // IERC4626:\n        // If (2) it’s determining the amount of the underlying tokens to\n        // transfer to them for returning a certain amount of shares, it should\n        // round down.\n        assets_ = shares_.fixedPointDiv(shareRatio_);\n    }\n\n    /// There is no onchain asset. The asset is offchain.\n    /// @inheritdoc IERC4626\n    function asset() public view virtual returns (address assetTokenAddress_) {\n        assetTokenAddress_ = _asset;\n    }\n\n    /// Any address can set their own minimum share ratio.\n    /// This is optional as the non-standard 4626 equivalent functions accept\n    /// a minimum share ratio parameter. This facilitates the 4626 interface by\n    /// adding one additional initial transaction for the user.\n    /// @param minShareRatio_ The new minimum share ratio for the `msg.sender`\n    /// to be used in subsequent deposit calls.\n    function setMinShareRatio(uint256 minShareRatio_) external {\n        minShareRatios[msg.sender] = minShareRatio_;\n    }\n\n    /// Any address can set their own ID for withdrawals.\n    /// This is optional as the non-standard 4626 equivalent functions accept\n    /// a withdrawal ID parameter. This facilitates the 4626 interface\n    /// by adding one initial transaction for the user.\n    /// @param id_ The new withdrawal id_ for the `msg.sender` to be used\n    /// in subsequent withdrawal calls. If the ID does NOT match the ID of a\n    /// receipt held by sender then these subsequent withdrawals will fail.\n    /// It is the responsibility of the caller to set a valid ID.\n    function setWithdrawId(uint256 id_) external {\n        withdrawIds[msg.sender] = id_;\n    }\n\n    /// @inheritdoc IERC4626\n    function totalAssets() external view virtual returns (uint256 assets_) {\n        // There are NO fees so the managed assets are the asset balance of the\n        // vault.\n        try IERC20(asset()).balanceOf(address(this)) returns (\n            uint256 balance_\n        ) {\n            assets_ = balance_;\n        } catch {\n            // It's not clear what the balance should be if querying it is\n            // throwing an error. The conservative error in most cases should\n            // be 0.\n            assets_ = 0;\n        }\n    }\n\n    /// Define the share ratio that assets are converted to shares on deposit.\n    /// This variant of `_shareRatio` MUST return the same result for all users.\n    /// As per IERC4626 `convertToShares` it should reflect the \"average-user's\"\n    /// share ratio when all conditions are met.\n    /// MUST NOT revert, instead return `0` and calling functions MUST revert or\n    /// return values as appropriate.\n    function _shareRatio() internal view virtual returns (uint256 shareRatio_) {\n        // Default is 1:1 shares to assets.\n        shareRatio_ = 1e18;\n    }\n\n    /// Define the share ratio that deposits convert to shares.\n    /// This variant of `_shareRatio` MAY return different results dependant on\n    /// the depositor and/or recipient as per `previewDeposit` and `deposit`.\n    /// MUST NOT revert.\n    function _shareRatio(address, address)\n        internal\n        view\n        virtual\n        returns (uint256 shareRatio_)\n    {\n        // Default is to fallback to user agnostic share ratio.\n        shareRatio_ = _shareRatio();\n    }\n\n    function _shareRatioForId(uint256)\n        internal\n        view\n        virtual\n        returns (uint256 shareRatio_)\n    {\n        // Default is the same as share ratio with no id.\n        shareRatio_ = _shareRatio();\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    function _nextId() internal virtual returns (uint256) {}\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets_)\n        external\n        view\n        returns (uint256 shares_)\n    {\n        shares_ = _calculateDeposit(assets_, _shareRatio(), 0);\n    }\n\n    /// This function is a bit weird because in reality everyone converts their\n    /// shares to assets at the share ratio they minted at, NOT the current\n    /// share ratio. But the spec demands that this function ignores per-user\n    /// concerns.\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares_)\n        external\n        view\n        returns (uint256 assets_)\n    {\n        assets_ = _calculateRedeem(shares_, _shareRatio());\n    }\n\n    /// @inheritdoc IERC4626\n    function maxDeposit(address)\n        external\n        pure\n        virtual\n        returns (uint256 maxAssets_)\n    {\n        // The spec states to return this if there is no deposit limit.\n        // Technically a deposit this large would almost certainly overflow\n        // somewhere in the process, but it isn't a limit imposed by the vault\n        // per-se, it's more that the ERC20 tokens themselves won't handle such\n        // large entries on their internal balances. Given typical token\n        // total supplies are smaller than this number, this would be a\n        // theoretical point only.\n        maxAssets_ = type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address)\n        external\n        pure\n        virtual\n        returns (uint256 maxShares_)\n    {\n        maxShares_ = type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 assets_)\n        external\n        view\n        virtual\n        returns (uint256 shares_)\n    {\n        shares_ = _calculateDeposit(\n            assets_,\n            // Spec doesn't provide us with a receipient but wants a per-user\n            // preview so we assume that depositor = receipient.\n            _shareRatio(msg.sender, msg.sender),\n            // IERC4626:\n            // > MUST NOT revert due to vault specific user/global limits.\n            // > MAY revert due to other conditions that would also cause\n            // > deposit to revert.\n            // Unclear if the min share ratio set by the user for themselves is\n            // a \"vault specific user limit\" or \"other conditions that would\n            // also cause deposit to revert\".\n            // The conservative interpretation is that the user will WANT\n            // the preview calculation to revert according to their own\n            // preferences they set for themselves onchain.\n            // If the user did not set a min ratio then the min ratio will be 0\n            // and never revert.\n            minShareRatios[msg.sender]\n        );\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares_)\n        public\n        view\n        virtual\n        returns (uint256 assets_)\n    {\n        assets_ = _calculateMint(\n            shares_,\n            // Spec doesn't provide us with a recipient but wants a per-user\n            // preview so we assume that depositor = recipient.\n            _shareRatio(msg.sender, msg.sender),\n            // IERC4626:\n            // > MUST NOT revert due to vault specific user/global limits.\n            // > MAY revert due to other conditions that would also cause mint\n            // > to revert.\n            // Unclear if the min share ratio set by the user for themselves is\n            // a \"vault specific user limit\" or \"other conditions that would\n            // also cause mint to revert\".\n            // The conservative interpretation is that the user will WANT\n            // the preview calculation to revert according to their own\n            // preferences they set for themselves onchain.\n            // If the user did not set a min ratio the min ratio will be 0 and\n            // never revert.\n            minShareRatios[msg.sender]\n        );\n    }\n\n    /// If the sender wants to use the ERC4626 `deposit` function and set a\n    /// minimum ratio they need to call `setMinShareRatio` first in a separate\n    /// call. Alternatively they can use the off-spec overloaded `deposit`\n    /// method.\n    /// @inheritdoc IERC4626\n    function deposit(uint256 assets_, address receiver_)\n        external\n        returns (uint256 shares_)\n    {\n        shares_ = deposit(assets_, receiver_, minShareRatios[msg.sender], \"\");\n    }\n\n    /// Overloaded `deposit` to allow `minShareRatio_` to be passed directly\n    /// without the additional `setMinShareRatio` call, which saves gas and can\n    /// provide a better UX overall.\n    /// @param assets_ As per IERC4626 `deposit`.\n    /// @param receiver_ As per IERC4626 `deposit`.\n    /// @param minShareRatio_ Caller can set the minimum share ratio they'll\n    /// accept from the oracle, otherwise the transaction is rolled back.\n    /// @param receiptInformation_ Forwarded to `receiptInformation` to\n    /// optionally emit offchain context about this deposit.\n    /// @return shares_ As per IERC4626 `deposit`.\n    function deposit(\n        uint256 assets_,\n        address receiver_,\n        uint256 minShareRatio_,\n        bytes memory receiptInformation_\n    ) public returns (uint256 shares_) {\n        uint256 shareRatio_ = _shareRatio(msg.sender, receiver_);\n        require(minShareRatio_ <= shareRatio_, \"MIN_SHARE_RATIO\");\n        shares_ = _calculateDeposit(assets_, shareRatio_, minShareRatio_);\n\n        _deposit(assets_, receiver_, shares_, _nextId(), receiptInformation_);\n    }\n\n    /// Handles minting and emitting events according to spec.\n    /// It does NOT do any calculations so shares and assets need to be handled\n    /// correctly according to spec including rounding, in the calling context.\n    /// Depositing reentrantly is never ok so we restrict that here in the\n    /// internal function rather than on the external methods.\n    /// @param assets_ As per IERC4626 `deposit`.\n    /// @param receiver_ As per IERC4626 `deposit`.\n    /// @param shares_ Amount of shares to mint for receiver. MAY be different\n    /// due to rounding in different contexts so caller MUST calculate\n    /// according to the rounding specification.\n    /// @param id_ ID of the 1155 receipt and MUST be provided on withdrawal.\n    function _deposit(\n        uint256 assets_,\n        address receiver_,\n        uint256 shares_,\n        uint256 id_,\n        bytes memory receiptInformation_\n    ) internal nonReentrant {\n        require(assets_ > 0, \"0_ASSETS\");\n        require(receiver_ != address(0), \"0_RECEIVER\");\n        require(shares_ > 0, \"0_SHARES\");\n        require(id_ > 0, \"0_ID\");\n        emit IERC4626.Deposit(msg.sender, receiver_, assets_, shares_);\n        emit DepositWithReceipt(\n            msg.sender,\n            receiver_,\n            assets_,\n            shares_,\n            id_,\n            receiptInformation_\n        );\n        _beforeDeposit(assets_, receiver_, shares_, id_);\n\n        // erc20 mint.\n        _mint(receiver_, shares_);\n\n        // erc1155 mint.\n        // Receiving contracts MUST implement `IERC1155Receiver`.\n        IReceipt(_receipt).ownerMint(\n            receiver_,\n            id_,\n            shares_,\n            receiptInformation_\n        );\n    }\n\n    function _beforeDeposit(\n        uint256 assets_,\n        address,\n        uint256,\n        uint256\n    ) internal virtual {\n        // Default behaviour is to move assets before minting shares.\n        IERC20(asset()).safeTransferFrom(msg.sender, address(this), assets_);\n    }\n\n    /// If the sender wants to use the ERC4626 `mint` function and set a\n    /// minimum share ratio they need to call `setMinShareRatio` first in a\n    /// separate call.\n    /// Alternatively they can use the off-spec overloaded `mint` method.\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares_, address receiver_)\n        external\n        returns (uint256 assets_)\n    {\n        assets_ = mint(shares_, receiver_, minShareRatios[msg.sender], \"\");\n    }\n\n    /// Overloaded version of IERC4626 `mint` that allows directly passing the\n    /// minimum share ratio to avoid additional gas and transactions.\n    /// @param shares_ As per IERC4626 `mint`.\n    /// @param receiver_ As per IERC4626 `mint`.\n    /// @param minShareRatio_ Caller can set the minimum ratio they'll accept\n    /// minting shares at, otherwise the transaction is rolled back.\n    /// @param receiptInformation_ Forwarded to `receiptInformation` to\n    /// optionally emit offchain context about this deposit.\n    /// @return assets_ As per IERC4626 `mint`.\n    function mint(\n        uint256 shares_,\n        address receiver_,\n        uint256 minShareRatio_,\n        bytes memory receiptInformation_\n    ) public returns (uint256 assets_) {\n        uint256 shareRatio_ = _shareRatio(msg.sender, receiver_);\n        require(minShareRatio_ <= shareRatio_, \"MIN_SHARE_RATIO\");\n        assets_ = _calculateMint(shares_, shareRatio_, minShareRatio_);\n        _deposit(assets_, receiver_, shares_, _nextId(), receiptInformation_);\n    }\n\n    /// As withdrawal requires a ID the vault deposits are non fungible. This\n    /// means the maximum amount of underlying asset that a user can withdraw is\n    /// specific to the 1155 receipt they want to burn to handle the withdraw.\n    /// A user with multiple receipts will only ever see the maxWithdraw for a\n    /// single receipt. For most use cases it would be recommended to call the\n    /// overloaded `maxWithdraw` that has the withdraw ID paramaterised. This\n    /// can be looped over to build a view over several withdraw IDs.\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address owner_)\n        external\n        view\n        virtual\n        returns (uint256 maxAssets_)\n    {\n        maxAssets_ = maxWithdraw(owner_, withdrawIds[owner_]);\n    }\n\n    /// Overloaded `maxWithdraw` that allows passing a receipt id directly. The\n    /// id needs to be provided so that we know which ERC1155 balance to\n    /// check the withdraw against. The burnable ERC20 is capped per-withdraw\n    /// to the balance of a ID-bound ERC1155. If a user has multiple 1155\n    /// receipts they will need to call `maxWithdraw` multiple times to\n    /// calculate a global withdrawal limit across all receipts.\n    /// @param owner_ As per IERC4626 `maxWithdraw`.\n    /// @param id_ The reference id to check the max withdrawal against\n    /// for a specific receipt the owner presumably holds. Max withdrawal will\n    /// be 0 if the user does not hold a receipt.\n    /// @return maxAssets_ As per IERC4626 `maxWithdraw`.\n    function maxWithdraw(address owner_, uint256 id_)\n        public\n        view\n        returns (uint256 maxAssets_)\n    {\n        // Using `_calculateRedeem` instead of `_calculateWithdraw` becuase the\n        // latter requires knowing the assets being withdrawn, which is what we\n        // are attempting to reverse engineer from the owner's receipt balance.\n        maxAssets_ = _calculateRedeem(\n            IReceipt(_receipt).balanceOf(owner_, id_),\n            _shareRatioForId(id_)\n        );\n    }\n\n    /// Previewing withdrawal will only calculate the shares required to\n    /// withdraw assets against their singular preset withdraw ID. To\n    /// calculate many withdrawals for a set of recieipts it is cheaper and\n    /// easier to use the overloaded version that allows IDs to be passed in\n    /// as arguments.\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets_)\n        external\n        view\n        returns (uint256 shares_)\n    {\n        shares_ = previewWithdraw(assets_, withdrawIds[msg.sender]);\n    }\n\n    /// Overloaded version of IERC4626 that allows caller to pass in the ID\n    /// to preview. Multiple receipt holders will need to call this function\n    /// for each recieipt ID to preview all their withdrawals.\n    /// @param assets_ As per IERC4626 `previewWithdraw`.\n    /// @param id_ The receipt to preview a withdrawal against.\n    /// @return shares_ As per IERC4626 `previewWithdraw`.\n    function previewWithdraw(uint256 assets_, uint256 id_)\n        public\n        view\n        virtual\n        returns (uint256 shares_)\n    {\n        shares_ = _calculateWithdraw(assets_, _shareRatioForId(id_));\n    }\n\n    /// Withdraws against the current withdraw ID set by the owner.\n    /// This enables spec compliant withdrawals but is additional gas and\n    /// transactions for the user to set the withdraw ID in storage before\n    /// each withdrawal. The overloaded `withdraw` function allows passing in a\n    /// receipt ID directly, which may be cheaper and more convenient.\n    /// @inheritdoc IERC4626\n    function withdraw(\n        uint256 assets_,\n        address receiver_,\n        address owner_\n    ) external returns (uint256 shares_) {\n        shares_ = withdraw(assets_, receiver_, owner_, withdrawIds[owner_]);\n    }\n\n    /// Overloaded version of IERC4626 `withdraw` that allows the id to be\n    /// passed directly.\n    /// @param assets_ As per IERC4626 `withdraw`.\n    /// @param receiver_ As per IERC4626 `withdraw`.\n    /// @param owner_ As per IERC4626 `withdraw`.\n    /// @param id_ As per `_withdraw`.\n    function withdraw(\n        uint256 assets_,\n        address receiver_,\n        address owner_,\n        uint256 id_\n    ) public returns (uint256 shares_) {\n        shares_ = _calculateWithdraw(assets_, _shareRatioForId(id_));\n        _withdraw(assets_, receiver_, owner_, shares_, id_);\n    }\n\n    /// Handles burning shares, withdrawing assets and emitting events to spec.\n    /// It does NOT do any calculations so shares and assets need to be correct\n    /// according to spec including rounding, in the calling context.\n    /// Withdrawing reentrantly is never ok so we restrict that here in the\n    /// internal function rather than on the external methods.\n    /// @param assets_ As per IERC4626 `withdraw`.\n    /// @param receiver_ As per IERC4626 `withdraw`.\n    /// @param owner_ As per IERC4626 `withdraw`.\n    /// @param shares_ Caller MUST calculate the correct shares to burn for\n    /// withdrawal at `shareRatio_`. It is caller's responsibility to handle\n    /// rounding correctly as per 4626 spec.\n    /// @param id_ The receipt id to withdraw against. The owner MUST hold the\n    /// receipt for the ID in addition to the shares being burned for\n    /// withdrawal.\n    function _withdraw(\n        uint256 assets_,\n        address receiver_,\n        address owner_,\n        uint256 shares_,\n        uint256 id_\n    ) internal nonReentrant {\n        require(assets_ > 0, \"0_ASSETS\");\n        require(receiver_ != address(0), \"0_RECEIVER\");\n        require(owner_ != address(0), \"0_OWNER\");\n        require(shares_ > 0, \"0_SHARES\");\n\n        emit IERC4626.Withdraw(msg.sender, receiver_, owner_, assets_, shares_);\n        emit WithdrawWithReceipt(\n            msg.sender,\n            receiver_,\n            owner_,\n            assets_,\n            shares_,\n            id_\n        );\n\n        // IERC4626:\n        // > MUST support a withdraw flow where the shares are burned from owner\n        // > directly where owner is msg.sender or msg.sender has ERC-20\n        // > approval over the shares of owner.\n        // Note that we do NOT require the caller has allowance over the receipt\n        // in order to burn the shares to withdraw assets.\n        if (owner_ != msg.sender) {\n            _spendAllowance(owner_, msg.sender, shares_);\n        }\n\n        // erc20 burn.\n        _burn(owner_, shares_);\n\n        // erc1155 burn.\n        IReceipt(_receipt).ownerBurn(owner_, id_, shares_);\n\n        _afterWithdraw(assets_, receiver_, owner_, shares_, id_);\n    }\n\n    function _afterWithdraw(\n        uint256 assets_,\n        address receiver_,\n        address,\n        uint256,\n        uint256\n    ) internal virtual {\n        // Default is to send assets after burning shares.\n        IERC20(asset()).safeTransfer(receiver_, assets_);\n    }\n\n    /// Max redemption is only relevant to the currently set withdraw ID for\n    /// the owner. Checking a different max redemption requires the owner\n    /// setting a different withdraw ID which costs gas and an additional\n    /// transaction. The overloaded maxRedeem function allows the ID being\n    /// checked against to be passed in directly.\n    /// @inheritdoc IERC4626\n    function maxRedeem(address owner_)\n        external\n        view\n        returns (uint256 maxShares_)\n    {\n        maxShares_ = maxRedeem(owner_, withdrawIds[owner_]);\n    }\n\n    /// Overloaded maxRedeem function that allows the redemption ID to be\n    /// passed directly. The maximum number of shares that can be redeemed is\n    /// simply the balance of the associated receipt NFT the user holds for the\n    /// given ID.\n    /// @param owner_ As per IERC4626 `maxRedeem`.\n    /// @param id_ The reference id to check the owner's 1155 balance for.\n    /// @return maxShares_ As per IERC4626 `maxRedeem`.\n    function maxRedeem(address owner_, uint256 id_)\n        public\n        view\n        returns (uint256 maxShares_)\n    {\n        maxShares_ = IReceipt(_receipt).balanceOf(owner_, id_);\n    }\n\n    /// Preview redeem is only relevant to the currently set withdraw ID for\n    /// the caller. The overloaded previewRedeem allows the ID to be passed\n    /// directly which may avoid gas costs and additional transactions.\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 shares_)\n        external\n        view\n        returns (uint256 assets_)\n    {\n        assets_ = _calculateRedeem(shares_, withdrawIds[msg.sender]);\n    }\n\n    /// Overloaded previewRedeem that allows ID to redeem for to be passed\n    /// directly.\n    /// @param shares_ As per IERC4626.\n    /// @param id_ The receipt id_ to calculate redemption against.\n    function previewRedeem(uint256 shares_, uint256 id_)\n        public\n        view\n        virtual\n        returns (uint256 assets_)\n    {\n        assets_ = _calculateRedeem(shares_, id_);\n    }\n\n    /// Redeems with the currently set withdraw ID for the owner. The\n    /// overloaded redeem function allows the ID to be passed in rather than\n    /// set separately in storage.\n    /// @inheritdoc IERC4626\n    function redeem(\n        uint256 shares_,\n        address receiver_,\n        address owner_\n    ) external returns (uint256 assets_) {\n        assets_ = redeem(shares_, receiver_, owner_, withdrawIds[owner_]);\n    }\n\n    /// Overloaded redeem that allows the ID to redeem with to be passed in.\n    /// @param shares_ As per IERC4626 `redeem`.\n    /// @param receiver_ As per IERC4626 `redeem`.\n    /// @param owner_ As per IERC4626 `redeem`.\n    /// @param id_ The reference id to redeem against. The owner MUST hold\n    /// a receipt with id_ and it will be used to calculate the share ratio.\n    function redeem(\n        uint256 shares_,\n        address receiver_,\n        address owner_,\n        uint256 id_\n    ) public returns (uint256 assets_) {\n        assets_ = _calculateRedeem(shares_, _shareRatioForId(id_));\n        _withdraw(assets_, receiver_, owner_, shares_, id_);\n    }\n}\n"
        },
        "./contracts/vault/receipt/IReceipt.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity =0.8.17;\n\nimport {IERC1155Upgradeable as IERC1155} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\n\ninterface IReceipt is IERC1155 {\n    function ownerMint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external;\n\n    function ownerBurn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) external;\n\n    function ownerTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external;\n\n    function receiptInformation(uint256 id, bytes memory data) external;\n}\n"
        },
        "./contracts/vault/receipt/IReceiptOwner.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity =0.8.17;\n\ninterface IReceiptOwner {\n    function authorizeReceiptTransfer(address from, address to) external view;\n\n    function authorizeReceiptInformation(uint256 id, bytes memory data)\n        external\n        view;\n}\n"
        },
        "./contracts/vault/offchainAsset/OffchainAssetReceiptVaultFactory.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {Factory} from \"@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol\";\nimport {OffchainAssetReceiptVault, OffchainAssetReceiptVaultConfig, OffchainAssetVaultConfig, ReceiptVaultConfig} from \"./OffchainAssetReceiptVault.sol\";\nimport {Receipt, ReceiptFactory, ReceiptConfig} from \"../receipt/ReceiptFactory.sol\";\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\n/// @title OffchainAssetReceiptVaultFactory\n/// @notice Factory for creating and deploying `OffchainAssetReceiptVault`.\ncontract OffchainAssetReceiptVaultFactory is Factory {\n    event SetReceiptFactory(address caller, address receiptFactory);\n\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n    address public immutable receiptFactory;\n\n    /// Build the reference implementation to clone for each child.\n    constructor(address receiptFactory_) {\n        receiptFactory = receiptFactory_;\n        emit SetReceiptFactory(msg.sender, receiptFactory_);\n\n        address implementation_ = address(new OffchainAssetReceiptVault());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes memory data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        (\n            ReceiptConfig memory receiptConfig_,\n            OffchainAssetVaultConfig memory offchainAssetVaultConfig_\n        ) = abi.decode(data_, (ReceiptConfig, OffchainAssetVaultConfig));\n        Receipt receipt_ = ReceiptFactory(receiptFactory).createChildTyped(\n            receiptConfig_\n        );\n\n        address clone_ = Clones.clone(implementation);\n        receipt_.transferOwnership(clone_);\n\n        OffchainAssetReceiptVault(clone_).initialize(\n            OffchainAssetReceiptVaultConfig(\n                offchainAssetVaultConfig_.admin,\n                ReceiptVaultConfig(\n                    address(receipt_),\n                    offchainAssetVaultConfig_.vaultConfig\n                )\n            )\n        );\n        return clone_;\n    }\n\n    /// Typed wrapper for `createChild` with Source.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param receiptConfig_ Config for the new receipt contract that will be\n    /// owned by the vault.\n    /// @param offchainAssetVaultConfig_ Config for the `OffchainAssetReceiptVault`.\n    /// @return New `OffchainAssetVault` child contract address.\n    function createChildTyped(\n        ReceiptConfig memory receiptConfig_,\n        OffchainAssetVaultConfig memory offchainAssetVaultConfig_\n    ) external returns (OffchainAssetReceiptVault) {\n        return\n            OffchainAssetReceiptVault(\n                createChild(\n                    abi.encode(receiptConfig_, offchainAssetVaultConfig_)\n                )\n            );\n    }\n}\n"
        },
        "./contracts/vault/receipt/ReceiptFactory.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {Factory} from \"@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol\";\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\nimport {Receipt, ReceiptConfig} from \"./Receipt.sol\";\n\ncontract ReceiptFactory is Factory {\n    address public immutable implementation;\n\n    constructor() {\n        address implementation_ = address(new Receipt());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes memory data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        ReceiptConfig memory config_ = abi.decode(data_, (ReceiptConfig));\n        address clone_ = Clones.clone(implementation);\n        Receipt(clone_).initialize(config_);\n        Receipt(clone_).transferOwnership(msg.sender);\n        return clone_;\n    }\n\n    /// Typed wrapper for `createChild` with Source.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ construction config for the `Receipt`.\n    /// @return New `Receipt` child contract address.\n    function createChildTyped(ReceiptConfig memory config_)\n        external\n        returns (Receipt)\n    {\n        return Receipt(createChild(abi.encode(config_)));\n    }\n}\n"
        },
        "./contracts/vault/receipt/Receipt.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity =0.8.17;\n\nimport {ERC1155Upgradeable as ERC1155} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport {OwnableUpgradeable as Ownable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./IReceiptOwner.sol\";\nimport \"./IReceipt.sol\";\n\nstruct ReceiptConfig {\n    string uri;\n}\n\ncontract Receipt is IReceipt, Ownable, ERC1155 {\n    /// Emitted when new information is provided for a receipt.\n    /// @param caller `msg.sender` emitting the information for the receipt.\n    /// @param id Receipt the information is for.\n    /// @param information Information for the receipt. MAY reference offchain\n    /// data where the payload is large.\n    event ReceiptInformation(address caller, uint256 id, bytes information);\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(ReceiptConfig memory config_) external initializer {\n        __Ownable_init();\n        __ERC1155_init(config_.uri);\n    }\n\n    /// @inheritdoc IReceipt\n    function ownerMint(\n        address account_,\n        uint256 id_,\n        uint256 amount_,\n        bytes memory data_\n    ) external onlyOwner {\n        _mint(account_, id_, amount_, data_);\n        receiptInformation(id_, data_);\n    }\n\n    /// @inheritdoc IReceipt\n    function ownerBurn(\n        address account_,\n        uint256 id_,\n        uint256 amount_\n    ) external onlyOwner {\n        _burn(account_, id_, amount_);\n    }\n\n    /// @inheritdoc IReceipt\n    function ownerTransferFrom(\n        address from_,\n        address to_,\n        uint256 id_,\n        uint256 amount_,\n        bytes memory data_\n    ) external onlyOwner {\n        _safeTransferFrom(from_, to_, id_, amount_, data_);\n    }\n\n    /// @inheritdoc ERC1155\n    function _beforeTokenTransfer(\n        address operator_,\n        address from_,\n        address to_,\n        uint256[] memory ids_,\n        uint256[] memory amounts_,\n        bytes memory data_\n    ) internal virtual override {\n        super._beforeTokenTransfer(\n            operator_,\n            from_,\n            to_,\n            ids_,\n            amounts_,\n            data_\n        );\n        IReceiptOwner(owner()).authorizeReceiptTransfer(from_, to_);\n    }\n\n    /// @inheritdoc IReceipt\n    function receiptInformation(uint256 id_, bytes memory data_) public {\n        // No data is noop.\n        if (data_.length > 0) {\n            IReceiptOwner(owner()).authorizeReceiptInformation(id_, data_);\n            emit ReceiptInformation(msg.sender, id_, data_);\n        }\n    }\n}\n"
        },
        "./contracts/vault/priceOracle/ERC20PriceOracleReceiptVault.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity =0.8.17;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ReceiptVaultConfig, VaultConfig, ReceiptVault} from \"../receipt/ReceiptVault.sol\";\nimport \"../../oracle/price/IPriceOracle.sol\";\n\nstruct ERC20PriceOracleVaultConfig {\n    address priceOracle;\n    VaultConfig vaultConfig;\n}\n\n/// @param asset `ERC4626` underlying asset.\n/// @param name `ERC20` name for `ERC4626` shares.\n/// @param symbol `ERC20` symbol for `ERC4626` shares.\n/// @param uri `ERC1155` uri for deposit receipts.\n/// @param address `IPriceOracle` oracle to define share mints upon deposit.\nstruct ERC20PriceOracleReceiptVaultConfig {\n    address priceOracle;\n    ReceiptVaultConfig receiptVaultConfig;\n}\n\n/// @title ERC20PriceOracleVault\n/// @notice An ERC4626 vault that mints shares according to a price oracle. As\n/// shares are minted an associated ERC1155 NFT receipt is minted for the\n/// asset depositor. The price oracle defines the amount of shares minted for\n/// each deposit. The price oracle's base MUST be the deposited asset but the\n/// price quote can be anything with a reliable oracle.\n///\n/// When the assets are withdrawn from the vault, the withdrawer must provide a\n/// receipt from a previous deposit. The receipt amount and the original\n/// shares minted are the same according to the price at the time of deposit.\n/// The withdraw burns shares in return for assets as per ERC4626 AND burns the\n/// receipt nominated by the withdrawer. The current price from the oracle is\n/// irrelevant to withdraws, only the receipt price is relevant.\n///\n/// As an analogy, consider buying a shirt on sale and then attempting to get a\n/// refund for it after the sale ends. The store will refund the shirt but only\n/// at the sale price marked on the receipt, NOT the current price of the same\n/// shirt in-store.\n///\n/// This dual 20/1155 token system allows for a dynamic shares:asset mint\n/// ratio on deposits without withdrawals ever being able to remove more assets\n/// than were ever deposited.\n///\n/// Where this gets interesting is trying to discover a price for the ERC20\n/// share token. The share token can't be worth 0 because it represents a claim\n/// on a fully collateralized vault of assets. The share token also can't be\n/// worth more than the current oracle price as it would allow depositors to\n/// buy infinite assets. To see why this is true, consider that selling 1 asset\n/// for a token pegged to the price buys the same number of pegged tokens as\n/// depositing 1 asset yields minted shares. If 1 share buys more than 1 pegged\n/// token then depositing 1 asset and selling the minted shares buys more than\n/// 1 asset. This sets up an infinite loop which can't exist in a real market.\n///\n/// ERC20PriceOracleVault shares are useful primitives that convert a valuable\n/// but volatile asset (e.g. wBTC/wETH) into shares that trade in a range (0, 1)\n/// of some reference price. Such a primitive MAY have trustless utility in\n/// domains such as providing liquidity on DEX/AMMs, non-liquidating leverage\n/// for speculation, risk management, etc.\n///\n/// Note on use of price oracles:\n/// At the time of writing Chainlink oracles seem to be \"best in class\" oracles\n/// yet suffer from several points of centralisation and counterparty risk. As\n/// there are no owner/admin keys on `ERC20PriceOracleVault` this represents an\n/// existential risk to the system if the price feeds stop behaving correctly.\n/// This is because the wrong number of shares will be minted upon deposit and\n/// nobody can modify the oracle address read by the vault. Long term holders\n/// of the share tokens are the most likely bagholders in the case of some\n/// oracle degradation as the fundamental tokenomics could break in arbitrary\n/// ways due to incorrect minting.\n///\n/// Oracles can be silently paused:\n/// Such as during the UST depegging event when Luna price was misreported by\n/// chainlink oracles. Chainlink oracles report timestamps since last update\n/// but every oracle has its own \"heartbeat\" during which prices are able to\n/// NOT update unless the price deviation target is hit. It is impossible to\n/// know from onchain timestamps within a heartbeat whether a price deviation\n/// has not been hit or if a price deviation has been hit but the feed is\n/// paused. The impact of this is specific to the configuration of the feed\n/// which is NOT visible onchain, for example at the time of writing ETH/USD\n/// feed updates every block, which the XAU/USD feed has a 24 hour heartbeat.\n/// Even if we read the current values that may be defined in the code of the\n/// oracle contract (but are not exposed via the interface to be read from other\n/// contracts) and set the same values in our contract, the upstream values can\n/// be changed at any time through a contract upgrade. As Chainlink admins are\n/// a company acting on instruction from clients (how the example UST price\n/// pausing came into being) it's relatively easy for someone to request a\n/// pause threshold to be added, changed or removed at any time.\n///\n/// Oracles are owned and can be modified:\n/// The underlying aggregator for an oracle can be changed by the owner. A new\n/// aggregator may have different heartbeat and deviance parameters, so an\n/// already deployed guard against stale data could become overly conservative\n/// and start blocking deposits unnecessarily, for example.\n///\n/// Mitigations:\n/// The `IPriceOracle` contracts do their best to guard against stale or\n/// invalid data by erroring which would pause all new depositing, while still\n/// allowing withdrawing. The `ChainlinkFeedPriceOracle` also does its best to\n/// read the onchain data that does exist such as `decimals` before converting\n/// prices to 18 decimal fixed point values. The best case scenario under a\n/// broken oracle is that most users become aware of what is happening and pull\n/// their collateral. One problem is that the system is designed to force some\n/// collateral to be \"sticky\" in the vault as different wallets hold the 1155\n/// and 20 tokens, so co-ordinating them for redemption may be impossible. In\n/// this case it MAY be possible to build anew vault contract that includes a\n/// matchmaking service for the compromised vault, to redeem old collateral for\n/// itself and reissue new tokens against itself. At the time of writing such a\n/// migration path is NOT implemented.\n///\n/// Note on ERC4626 rounding requirements:\n/// In various places the ERC4626 specification defines whether a function\n/// rounds up or round down when calculating mints and burns. This is to ensure\n/// that rounding erros always favour the vault, in that deposited assets will\n/// slowly accrue as dust (1 wei per rounding error) wherever the deposit and\n/// withdraw round trip cannot be precisely calculated. Technically to achieve\n/// this we should do something like the Open Zeppelin `ceilDiv` function that\n/// includes checks that `X % Y == 0` before rounding up after the integer\n/// division that first floors the result. We don't do that. To achieve the\n/// stated goals of ERC4626 rounding, which is setting aside 1 wei for security\n/// to guarantee total withdrawals are strictly <= deposits, we always add 1\n/// wei to the \"round up\" function results unconditionally. This saves gas and\n/// simplifies the contract overall.\ncontract ERC20PriceOracleReceiptVault is ReceiptVault {\n    /// Emitted when deployed and constructed.\n    /// @param caller `msg.sender` that deployed the contract.\n    /// @param config All construction config.\n    event ERC20PriceOracleReceiptVaultInitialized(\n        address caller,\n        ERC20PriceOracleReceiptVaultConfig config\n    );\n\n    /// The price oracle used for all minting calculations.\n    IPriceOracle public priceOracle;\n\n    function initialize(ERC20PriceOracleReceiptVaultConfig memory config_)\n        external\n        initializer\n    {\n        __ReceiptVault_init(config_.receiptVaultConfig);\n        priceOracle = IPriceOracle(config_.priceOracle);\n        emit ERC20PriceOracleReceiptVaultInitialized(msg.sender, config_);\n    }\n\n    /// @inheritdoc ReceiptVault\n    function _nextId() internal view override returns (uint256 id_) {\n        id_ = priceOracle.price();\n    }\n\n    function _shareRatio()\n        internal\n        view\n        override\n        returns (uint256 shareRatio_)\n    {\n        // The oracle CAN error so we wrap in a try block to meet spec\n        // requirement that calls MUST NOT revert.\n        try priceOracle.price() returns (uint256 price_) {\n            shareRatio_ = price_;\n        } catch {\n            // Depositing assets while the price oracle is erroring will give 0\n            // shares (it will revert due to 0 ratio).\n            shareRatio_ = 0;\n        }\n    }\n\n    function _shareRatioForId(uint256 id_)\n        internal\n        pure\n        override\n        returns (uint256 shareRatio_)\n    {\n        shareRatio_ = id_;\n    }\n}\n"
        },
        "./contracts/vault/priceOracle/ERC20PriceOracleReceiptVaultFactory.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {Factory} from \"@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol\";\nimport {ERC20PriceOracleReceiptVault, ERC20PriceOracleReceiptVaultConfig, ERC20PriceOracleVaultConfig, ReceiptVaultConfig} from \"./ERC20PriceOracleReceiptVault.sol\";\nimport {Receipt, ReceiptFactory, ReceiptConfig} from \"../receipt/ReceiptFactory.sol\";\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\n/// @title ERC20PriceOracleReceiptVaultFactory\n/// @notice Factory for creating and deploying `ERC20PriceOracleReceiptVault`.\ncontract ERC20PriceOracleReceiptVaultFactory is Factory {\n    event SetReceiptFactory(address caller, address receiptFactory);\n\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n    address public immutable receiptFactory;\n\n    /// Build the reference implementation to clone for each child.\n    constructor(address receiptFactory_) {\n        receiptFactory = receiptFactory_;\n        emit SetReceiptFactory(msg.sender, receiptFactory_);\n\n        address implementation_ = address(new ERC20PriceOracleReceiptVault());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes memory data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        (\n            ReceiptConfig memory receiptConfig_,\n            ERC20PriceOracleVaultConfig memory erc20PriceOracleVaultConfig_\n        ) = abi.decode(data_, (ReceiptConfig, ERC20PriceOracleVaultConfig));\n        Receipt receipt_ = ReceiptFactory(receiptFactory).createChildTyped(\n            receiptConfig_\n        );\n\n        address clone_ = Clones.clone(implementation);\n        receipt_.transferOwnership(clone_);\n\n        ERC20PriceOracleReceiptVault(clone_).initialize(\n            ERC20PriceOracleReceiptVaultConfig(\n                erc20PriceOracleVaultConfig_.priceOracle,\n                ReceiptVaultConfig(\n                    address(receipt_),\n                    erc20PriceOracleVaultConfig_.vaultConfig\n                )\n            )\n        );\n        return clone_;\n    }\n\n    /// Typed wrapper for `createChild` with Source.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param receiptConfig_ Config for the new receipt contract that will be\n    /// owned by the vault.\n    /// @param erc20PriceOracleVaultConfig_ Config for the `ERC20PriceOracleReceiptVault`.\n    /// @return New `ERC20PriceOracleReceiptVault` child contract address.\n    function createChildTyped(\n        ReceiptConfig memory receiptConfig_,\n        ERC20PriceOracleVaultConfig memory erc20PriceOracleVaultConfig_\n    ) external returns (ERC20PriceOracleReceiptVault) {\n        return\n            ERC20PriceOracleReceiptVault(\n                createChild(\n                    abi.encode(receiptConfig_, erc20PriceOracleVaultConfig_)\n                )\n            );\n    }\n}\n"
        },
        "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
        },
        "@beehiveinnovation/rain-protocol/contracts/chainlink/LibChainlink.sol": {
            "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../math/FixedPointMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nlibrary LibChainlink {\n    using SafeCast for int256;\n    using FixedPointMath for uint256;\n\n    function price(\n        address feed_,\n        uint256 staleAfter_\n    ) internal view returns (uint256) {\n        (, int256 answer_, , uint256 updatedAt_, ) = AggregatorV3Interface(\n            feed_\n        ).latestRoundData();\n        require(answer_ > 0, \"MIN_BASE_PRICE\");\n        // Checked time comparison ensures no updates from the future as that\n        // would overflow, and no stale prices.\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp - updatedAt_ < staleAfter_, \"STALE_PRICE\");\n\n        // Safely cast the answer to uint and scale it to 18 decimal FP.\n        return\n            answer_.toUint256().scale18(\n                AggregatorV3Interface(feed_).decimals()\n            );\n    }\n}\n"
        },
        "@beehiveinnovation/rain-protocol/contracts/math/FixedPointMath.sol": {
            "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\n/// @dev The scale of all fixed point math. This is adopting the conventions of\n/// both ETH (wei) and most ERC20 tokens, so is hopefully uncontroversial.\nuint256 constant FP_DECIMALS = 18;\n/// @dev The number `1` in the standard fixed point math scaling. Most of the\n/// differences between fixed point math and regular math is multiplying or\n/// dividing by `ONE` after the appropriate scaling has been applied.\nuint256 constant FP_ONE = 1e18;\n\n/// @title FixedPointMath\n/// @notice Sometimes we want to do math with decimal values but all we have\n/// are integers, typically uint256 integers. Floats are very complex so we\n/// don't attempt to simulate them. Instead we provide a standard definition of\n/// \"one\" as 10 ** 18 and scale everything up/down to this as fixed point math.\n/// Overflows are errors as per Solidity.\nlibrary FixedPointMath {\n    using Math for uint256;\n\n    /// Scale a fixed point decimal of some scale factor to match `DECIMALS`.\n    /// @param a_ Some fixed point decimal value.\n    /// @param aDecimals_ The number of fixed decimals of `a_`.\n    /// @return `a_` scaled to match `DECIMALS`.\n    function scale18(\n        uint256 a_,\n        uint256 aDecimals_\n    ) internal pure returns (uint256) {\n        uint256 decimals_;\n        if (FP_DECIMALS == aDecimals_) {\n            return a_;\n        } else if (FP_DECIMALS > aDecimals_) {\n            unchecked {\n                decimals_ = FP_DECIMALS - aDecimals_;\n            }\n            return a_ * 10 ** decimals_;\n        } else {\n            unchecked {\n                decimals_ = aDecimals_ - FP_DECIMALS;\n            }\n            return a_ / 10 ** decimals_;\n        }\n    }\n\n    /// Scale a fixed point decimals of `DECIMALS` to some other scale.\n    /// @param a_ A `DECIMALS` fixed point decimals.\n    /// @param targetDecimals_ The new scale of `a_`.\n    /// @return `a_` rescaled from `DECIMALS` to `targetDecimals_`.\n    function scaleN(\n        uint256 a_,\n        uint256 targetDecimals_\n    ) internal pure returns (uint256) {\n        uint256 decimals_;\n        if (targetDecimals_ == FP_DECIMALS) {\n            return a_;\n        } else if (FP_DECIMALS > targetDecimals_) {\n            unchecked {\n                decimals_ = FP_DECIMALS - targetDecimals_;\n            }\n            return a_ / 10 ** decimals_;\n        } else {\n            unchecked {\n                decimals_ = targetDecimals_ - FP_DECIMALS;\n            }\n            return a_ * 10 ** decimals_;\n        }\n    }\n\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\n    /// The caller MUST ensure the end result matches `DECIMALS` if other\n    /// functions in this library are to work correctly.\n    /// Notably `scaleBy` is a SIGNED integer so scaling down by negative OOMS\n    /// is supported.\n    /// @param a_ Some integer of any scale.\n    /// @param scaleBy_ OOMs to scale `a_` up or down by.\n    /// @return `a_` rescaled according to `scaleBy_`.\n    function scaleBy(\n        uint256 a_,\n        int8 scaleBy_\n    ) internal pure returns (uint256) {\n        if (scaleBy_ == 0) {\n            return a_;\n        } else if (scaleBy_ > 0) {\n            return a_ * 10 ** uint8(scaleBy_);\n        } else {\n            uint256 posScaleDownBy_;\n            unchecked {\n                posScaleDownBy_ = uint8(-1 * scaleBy_);\n            }\n            return a_ / 10 ** posScaleDownBy_;\n        }\n    }\n\n    /// Fixed point multiplication in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointMul(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        return a_.mulDiv(b_, FP_ONE);\n    }\n\n    /// Fixed point division in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointDiv(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        return a_.mulDiv(FP_ONE, b_);\n    }\n}\n"
        },
        "@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol": {
            "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {IFactory} from \"./IFactory.sol\";\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title Factory\n/// @notice Base contract for deploying and registering child contracts.\nabstract contract Factory is IFactory, ReentrancyGuard {\n    /// @dev state to track each deployed contract address. A `Factory` will\n    /// never lie about deploying a child, unless `isChild` is overridden to do\n    /// so.\n    mapping(address => bool) private contracts;\n\n    constructor() {\n        // Technically `ReentrancyGuard` is initializable but allowing it to be\n        // initialized is a foot-gun as the status will be set to _NOT_ENTERED.\n        // This would allow re-entrant behaviour upon initialization of the\n        // `Factory` and is unnecessary as the reentrancy guard always restores\n        // _NOT_ENTERED after every call anyway.\n        _disableInitializers();\n    }\n\n    /// Implements `IFactory`.\n    ///\n    /// `_createChild` hook must be overridden to actually create child\n    /// contract.\n    ///\n    /// Implementers may want to overload this function with a typed equivalent\n    /// to expose domain specific structs etc. to the compiled ABI consumed by\n    /// tooling and other scripts. To minimise gas costs for deployment it is\n    /// expected that the tooling will consume the typed ABI, then encode the\n    /// arguments and pass them to this function directly.\n    ///\n    /// @param data_ ABI encoded data to pass to child contract constructor.\n    function _createChild(\n        bytes memory data_\n    ) internal virtual returns (address);\n\n    /// Implements `IFactory`.\n    ///\n    /// Calls the `_createChild` hook that inheriting contracts must override.\n    /// Registers child contract address such that `isChild` is `true`.\n    /// Emits `NewChild` event.\n    ///\n    /// @param data_ Encoded data to pass down to child contract constructor.\n    /// @return New child contract address.\n    function createChild(\n        bytes memory data_\n    ) public virtual override nonReentrant returns (address) {\n        // Create child contract using hook.\n        address child_ = _createChild(data_);\n        // Ensure the child at this address has not previously been deployed.\n        require(!contracts[child_], \"DUPLICATE_CHILD\");\n        // Register child contract address to `contracts` mapping.\n        contracts[child_] = true;\n        // Emit `NewChild` event with child contract address.\n        emit IFactory.NewChild(msg.sender, child_);\n        return child_;\n    }\n\n    /// Implements `IFactory`.\n    ///\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// @param maybeChild_ Address of child contract to look up.\n    /// @return Returns `true` if address is a contract created by this\n    /// contract factory, otherwise `false`.\n    function isChild(\n        address maybeChild_\n    ) external view virtual override returns (bool) {\n        return contracts[maybeChild_];\n    }\n}\n"
        },
        "@beehiveinnovation/rain-protocol/contracts/factory/IFactory.sol": {
            "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\ninterface IFactory {\n    /// Whenever a new child contract is deployed, a `NewChild` event\n    /// containing the new child contract address MUST be emitted.\n    /// @param sender `msg.sender` that deployed the contract (factory).\n    /// @param child address of the newly deployed child.\n    event NewChild(address sender, address child);\n\n    /// Factories that clone a template contract MUST emit an event any time\n    /// they set the implementation being cloned. Factories that deploy new\n    /// contracts without cloning do NOT need to emit this.\n    /// @param sender `msg.sender` that deployed the implementation (factory).\n    /// @param implementation address of the implementation contract that will\n    /// be used for future clones if relevant.\n    event Implementation(address sender, address implementation);\n\n    /// Creates a new child contract.\n    ///\n    /// @param data_ Domain specific data for the child contract constructor.\n    /// @return New child contract address.\n    function createChild(bytes calldata data_) external returns (address);\n\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// Addresses that were not deployed by `createChild` MUST NOT return\n    /// `true` from `isChild`. This is CRITICAL to the security guarantees for\n    /// any contract implementing `IFactory`.\n    ///\n    /// @param maybeChild_ Address to check registration for.\n    /// @return `true` if address was deployed by this contract factory,\n    /// otherwise `false`.\n    function isChild(address maybeChild_) external view returns (bool);\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
        },
        "@beehiveinnovation/rain-protocol/contracts/test/tier/TierV2/ReadWriteTier.sol": {
            "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {TierV2} from \"../../../tier/TierV2.sol\";\nimport \"../../../tier/libraries/TierConstants.sol\";\nimport \"../../../tier/libraries/TierReport.sol\";\n\n/// @title ReadWriteTier\n///\n/// Very simple TierV2 implementation for testing.\ncontract ReadWriteTier is TierV2 {\n    /// Every time a tier changes we log start and end tier against the\n    /// account.\n    /// This MAY NOT be emitted if reports are being read from the state of an\n    /// external contract.\n    /// The start tier MAY be lower than the current tier as at the block this\n    /// event is emitted in.\n    /// @param sender The `msg.sender` that authorized the tier change.\n    /// @param account The account changing tier.\n    /// @param startTier The previous tier the account held.\n    /// @param endTier The newly acquired tier the account now holds.\n    event TierChange(\n        address sender,\n        address account,\n        uint256 startTier,\n        uint256 endTier\n    );\n\n    /// account => reports\n    mapping(address => uint256) private reports;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// Either fetch the report from storage or return UNINITIALIZED.\n    /// @inheritdoc ITierV2\n    function report(\n        address account_,\n        uint256[] memory\n    ) public view virtual override returns (uint256) {\n        // Inequality here to silence slither warnings.\n        return\n            reports[account_] > 0\n                ? reports[account_]\n                : TierConstants.NEVER_REPORT;\n    }\n\n    /// @inheritdoc ITierV2\n    function reportTimeForTier(\n        address account_,\n        uint256 tier_,\n        uint256[] memory\n    ) external view returns (uint256) {\n        return\n            TierReport.reportTimeForTier(\n                report(account_, new uint256[](0)),\n                tier_\n            );\n    }\n\n    /// Errors if the user attempts to return to the ZERO tier.\n    /// Updates the report from `report` using default `TierReport` logic.\n    /// Emits `TierChange` event.\n    function setTier(address account_, uint256 endTier_) external {\n        // The user must move to at least tier 1.\n        // The tier 0 status is reserved for users that have never\n        // interacted with the contract.\n        require(endTier_ > 0, \"SET_ZERO_TIER\");\n\n        uint256 report_ = report(account_, new uint256[](0));\n\n        uint256 startTier_ = TierReport.tierAtTimeFromReport(\n            report_,\n            block.timestamp\n        );\n\n        reports[account_] = TierReport.updateReportWithTierAtTime(\n            report_,\n            startTier_,\n            endTier_,\n            block.timestamp\n        );\n\n        emit TierChange(msg.sender, account_, startTier_, endTier_);\n    }\n\n    /// Re-export TierReport utilities\n\n    function tierAtTimeFromReport(\n        uint256 report_,\n        uint256 timestamp_\n    ) external pure returns (uint256 tier_) {\n        return TierReport.tierAtTimeFromReport(report_, timestamp_);\n    }\n\n    function reportTimeForTier(\n        uint256 report_,\n        uint256 tier_\n    ) external pure returns (uint256 timestamp_) {\n        return TierReport.reportTimeForTier(report_, tier_);\n    }\n\n    function truncateTiersAbove(\n        uint256 report_,\n        uint256 tier_\n    ) external pure returns (uint256) {\n        return TierReport.truncateTiersAbove(report_, tier_);\n    }\n\n    function updateTimeAtTier(\n        uint256 report_,\n        uint256 tier_,\n        uint256 timestamp_\n    ) external pure returns (uint256 updatedReport_) {\n        return TierReport.updateTimeAtTier(report_, tier_, timestamp_);\n    }\n\n    function updateTimesForTierRange(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 timestamp_\n    ) external pure returns (uint256 updatedReport_) {\n        return\n            TierReport.updateTimesForTierRange(\n                report_,\n                startTier_,\n                endTier_,\n                timestamp_\n            );\n    }\n\n    function updateReportWithTierAtTime(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 timestamp_\n    ) external pure returns (uint256 updatedReport_) {\n        return\n            TierReport.updateReportWithTierAtTime(\n                report_,\n                startTier_,\n                endTier_,\n                timestamp_\n            );\n    }\n}\n"
        },
        "@beehiveinnovation/rain-protocol/contracts/tier/TierV2.sol": {
            "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {ERC165Upgradeable as ERC165} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"./ITierV2.sol\";\n\nabstract contract TierV2 is ITierV2, ERC165 {\n    // solhint-disable-next-line func-name-mixedcase\n    function __TierV2_init() internal onlyInitializing {\n        __ERC165_init();\n    }\n\n    // @inheritdoc ERC165\n    function supportsInterface(\n        bytes4 interfaceId_\n    ) public view virtual override returns (bool) {\n        return\n            interfaceId_ == type(ITierV2).interfaceId ||\n            super.supportsInterface(interfaceId_);\n    }\n}\n"
        },
        "@beehiveinnovation/rain-protocol/contracts/tier/ITierV2.sol": {
            "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title ITierV2\n/// @notice `ITierV2` is a simple interface that contracts can implement to\n/// provide membership lists for other contracts.\n///\n/// There are many use-cases for a time-preserving conditional membership list.\n///\n/// Some examples include:\n///\n/// - Self-serve whitelist to participate in fundraising\n/// - Lists of users who can claim airdrops and perks\n/// - Pooling resources with implied governance/reward tiers\n/// - POAP style attendance proofs allowing access to future exclusive events\n///\n/// @dev Standard interface to a tiered membership.\n///\n/// A \"membership\" can represent many things:\n/// - Exclusive access.\n/// - Participation in some event or process.\n/// - KYC completion.\n/// - Combination of sub-memberships.\n/// - Etc.\n///\n/// The high level requirements for a contract implementing `ITierV2`:\n/// - MUST represent held tiers as a `uint`.\n/// - MUST implement `report`.\n///   - The report is a `uint256` that SHOULD represent the time each tier has\n///     been continuously held since encoded as `uint32`.\n///   - The encoded tiers start at `1`; Tier `0` is implied if no tier has ever\n///     been held.\n///   - Tier `0` is NOT encoded in the report, it is simply the fallback value.\n///   - If a tier is lost the time data is erased for that tier and will be\n///     set if/when the tier is regained to the new time.\n///   - If a tier is held but the historical time information is not available\n///     the report MAY return `0x00000000` for all held tiers.\n///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.\n///   - Context can be a list of numbers that MAY pairwise define tiers such as\n///     minimum thresholds, or MAY simply provide global context such as a\n///     relevant NFT ID for example.\n/// - MUST implement `reportTimeForTier`\n///   - Functions exactly as `report` but only returns a single time for a\n///     single tier\n///   - MUST return the same time value `report` would for any given tier and\n///     context combination.\n///\n/// So the four possible states and report values are:\n/// - Tier is held and time is known: Timestamp is in the report\n/// - Tier is held but time is NOT known: `0` is in the report\n/// - Tier is NOT held: `0xFF..` is in the report\n/// - Tier is unknown: `0xFF..` is in the report\n///\n/// The reason `context` is specified as a list of values rather than arbitrary\n/// bytes is to allow clear and efficient compatibility with interpreter stacks.\n/// Some N values can be taken from an interpreter stack and used directly as a\n/// context, which would be difficult or impossible to ensure is safe for\n/// arbitrary bytes.\ninterface ITierV2 {\n    /// Same as report but only returns the time for a single tier.\n    /// Often the implementing contract can calculate a single tier more\n    /// efficiently than all 8 tiers. If the consumer only needs one or a few\n    /// tiers it MAY be much cheaper to request only those tiers individually.\n    /// This DOES NOT apply to all contracts, an obvious example is token\n    /// balance based tiers which always return `ALWAYS` or `NEVER` for all\n    /// tiers so no efficiency is gained.\n    /// The return value is a `uint256` for gas efficiency but the values will\n    /// be bounded by `type(uint32).max` as no single tier can report a value\n    /// higher than this.\n    function reportTimeForTier(\n        address account,\n        uint256 tier,\n        uint256[] calldata context\n    ) external view returns (uint256 time);\n\n    /// Returns an 8 tier encoded report of 32 bit timestamps for the given\n    /// account.\n    ///\n    /// Same as `ITier` (legacy interface) but with a list of values for\n    /// `context` which allows a single underlying state to present many\n    /// different reports dynamically.\n    ///\n    /// For example:\n    /// - Staking ledgers can calculate different tier thresholds\n    /// - NFTs can give different tiers based on different IDs\n    /// - Snapshot ERC20s can give different reports based on snapshot ID\n    ///\n    /// `context` supercedes `setTier` function and `TierChange` event from\n    /// `ITier` at the interface level.\n    function report(\n        address account,\n        uint256[] calldata context\n    ) external view returns (uint256 report);\n}\n"
        },
        "@beehiveinnovation/rain-protocol/contracts/tier/libraries/TierConstants.sol": {
            "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title TierConstants\n/// @notice Constants for use with tier logic.\nlibrary TierConstants {\n    /// NEVER is 0xFF.. as it is infinitely in the future.\n    /// NEVER for an entire report.\n    uint256 internal constant NEVER_REPORT = type(uint256).max;\n    /// NEVER for a single tier time.\n    uint32 internal constant NEVER_TIME = type(uint32).max;\n\n    /// Always is 0 as negative timestamps are not possible/supported onchain.\n    /// Tiers can't predate the chain but they can predate an `ITierV2`\n    /// contract.\n    uint256 internal constant ALWAYS = 0;\n\n    /// Account has never held a tier.\n    uint256 internal constant TIER_ZERO = 0;\n\n    /// Magic number for tier one.\n    uint256 internal constant TIER_ONE = 1;\n    /// Magic number for tier two.\n    uint256 internal constant TIER_TWO = 2;\n    /// Magic number for tier three.\n    uint256 internal constant TIER_THREE = 3;\n    /// Magic number for tier four.\n    uint256 internal constant TIER_FOUR = 4;\n    /// Magic number for tier five.\n    uint256 internal constant TIER_FIVE = 5;\n    /// Magic number for tier six.\n    uint256 internal constant TIER_SIX = 6;\n    /// Magic number for tier seven.\n    uint256 internal constant TIER_SEVEN = 7;\n    /// Magic number for tier eight.\n    uint256 internal constant TIER_EIGHT = 8;\n    /// Maximum tier is `TIER_EIGHT`.\n    uint256 internal constant MAX_TIER = TIER_EIGHT;\n}\n"
        },
        "@beehiveinnovation/rain-protocol/contracts/tier/libraries/TierReport.sol": {
            "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {ITierV2} from \"../ITierV2.sol\";\nimport \"./TierConstants.sol\";\n\n/// @title TierReport\n/// @notice `TierReport` implements several pure functions that can be\n/// used to interface with reports.\n/// - `tierAtTimeFromReport`: Returns the highest status achieved relative to\n/// a block timestamp and report. Statuses gained after that block are ignored.\n/// - `tierTime`: Returns the timestamp that a given tier has been held\n/// since according to a report.\n/// - `truncateTiersAbove`: Resets all the tiers above the reference tier.\n/// - `updateTimesForTierRange`: Updates a report with a timestamp for every\n///    tier in a range.\n/// - `updateReportWithTierAtTime`: Updates a report to a new tier.\n/// @dev Utilities to consistently read, write and manipulate tiers in reports.\n/// The low-level bit shifting can be difficult to get right so this\n/// factors that out.\nlibrary TierReport {\n    /// Enforce upper limit on tiers so we can do unchecked math.\n    /// @param tier_ The tier to enforce bounds on.\n    modifier maxTier(uint256 tier_) {\n        require(tier_ <= TierConstants.MAX_TIER, \"MAX_TIER\");\n        _;\n    }\n\n    /// Returns the highest tier achieved relative to a block timestamp\n    /// and report.\n    ///\n    /// Note that typically the report will be from the _current_ contract\n    /// state, i.e. `block.timestamp` but not always. Tiers gained after the\n    /// reference time are ignored.\n    ///\n    /// When the `report` comes from a later block than the `timestamp_` this\n    /// means the user must have held the tier continuously from `timestamp_`\n    /// _through_ to the report time.\n    /// I.e. NOT a snapshot.\n    ///\n    /// @param report_ A report as per `ITierV2`.\n    /// @param timestamp_ The timestamp to check the tiers against.\n    /// @return tier_ The highest tier held since `timestamp_` as per `report`.\n    function tierAtTimeFromReport(\n        uint256 report_,\n        uint256 timestamp_\n    ) internal pure returns (uint256 tier_) {\n        unchecked {\n            for (tier_ = 0; tier_ < 8; tier_++) {\n                if (uint32(uint256(report_ >> (tier_ * 32))) > timestamp_) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /// Returns the timestamp that a given tier has been held since from a\n    /// report.\n    ///\n    /// The report MUST encode \"never\" as 0xFFFFFFFF. This ensures\n    /// compatibility with `tierAtTimeFromReport`.\n    ///\n    /// @param report_ The report to read a timestamp from.\n    /// @param tier_ The Tier to read the timestamp for.\n    /// @return The timestamp the tier has been held since.\n    function reportTimeForTier(\n        uint256 report_,\n        uint256 tier_\n    ) internal pure maxTier(tier_) returns (uint256) {\n        unchecked {\n            // ZERO is a special case. Everyone has always been at least ZERO,\n            // since block 0.\n            if (tier_ == 0) {\n                return 0;\n            }\n\n            uint256 offset_ = (tier_ - 1) * 32;\n            return uint256(uint32(uint256(report_ >> offset_)));\n        }\n    }\n\n    /// Resets all the tiers above the reference tier to 0xFFFFFFFF.\n    ///\n    /// @param report_ Report to truncate with high bit 1s.\n    /// @param tier_ Tier to truncate above (exclusive).\n    /// @return Truncated report.\n    function truncateTiersAbove(\n        uint256 report_,\n        uint256 tier_\n    ) internal pure maxTier(tier_) returns (uint256) {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            uint256 mask_ = (TierConstants.NEVER_REPORT >> offset_) << offset_;\n            return report_ | mask_;\n        }\n    }\n\n    /// Updates a report with a timestamp for a given tier.\n    /// More gas efficient than `updateTimesForTierRange` if only a single\n    /// tier is being modified.\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\n    /// the time for tier `1`.\n    /// @param report_ Report to use as the baseline for the updated report.\n    /// @param tier_ The tier level to update.\n    /// @param timestamp_ The new block number for `tier_`.\n    /// @return The newly updated `report_`.\n    function updateTimeAtTier(\n        uint256 report_,\n        uint256 tier_,\n        uint256 timestamp_\n    ) internal pure maxTier(tier_) returns (uint256) {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            return\n                (report_ &\n                    ~uint256(uint256(TierConstants.NEVER_TIME) << offset_)) |\n                uint256(timestamp_ << offset_);\n        }\n    }\n\n    /// Updates a report with a block number for every tier in a range.\n    ///\n    /// Does nothing if the end status is equal or less than the start tier.\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier at the start of the range (exclusive).\n    /// @param endTier_ The tier at the end of the range (inclusive).\n    /// @param timestamp_ The timestamp to set for every tier in the range.\n    /// @return The updated report.\n    function updateTimesForTierRange(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 timestamp_\n    ) internal pure maxTier(endTier_) returns (uint256) {\n        unchecked {\n            uint256 offset_;\n            for (uint256 i_ = startTier_; i_ < endTier_; i_++) {\n                offset_ = i_ * 32;\n                report_ =\n                    (report_ &\n                        ~uint256(\n                            uint256(TierConstants.NEVER_TIME) << offset_\n                        )) |\n                    uint256(timestamp_ << offset_);\n            }\n            return report_;\n        }\n    }\n\n    /// Updates a report to a new status.\n    ///\n    /// Internally dispatches to `truncateTiersAbove` and\n    /// `updateBlocksForTierRange`.\n    /// The dispatch is based on whether the new tier is above or below the\n    /// current tier.\n    /// The `startTier_` MUST match the result of `tierAtBlockFromReport`.\n    /// It is expected the caller will know the current tier when\n    /// calling this function and need to do other things in the calling scope\n    /// with it.\n    ///\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier to start updating relative to. Data above\n    /// this tier WILL BE LOST so probably should be the current tier.\n    /// @param endTier_ The new highest tier held, at the given timestamp_.\n    /// @param timestamp_ The timestamp_ to update the highest tier to, and\n    /// intermediate tiers from `startTier_`.\n    /// @return The updated report.\n    function updateReportWithTierAtTime(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 timestamp_\n    ) internal pure returns (uint256) {\n        return\n            endTier_ < startTier_\n                ? truncateTiersAbove(report_, endTier_)\n                : updateTimesForTierRange(\n                    report_,\n                    startTier_,\n                    endTier_,\n                    timestamp_\n                );\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC20Snapshot.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ArraysUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\n * total supply at the time are recorded for later access.\n *\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\n * In naive implementations it's possible to perform a \"double spend\" attack by reusing the same balance from different\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\n * used to create an efficient ERC20 forking mechanism.\n *\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\n * and the account address.\n *\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\n * return `block.number` will trigger the creation of snapshot at the beginning of each new block. When overriding this\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\n *\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\n * alternative consider {ERC20Votes}.\n *\n * ==== Gas Costs\n *\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\n *\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\n * transfers will have normal cost until the next snapshot, and so on.\n */\n\nabstract contract ERC20SnapshotUpgradeable is Initializable, ERC20Upgradeable {\n    function __ERC20Snapshot_init() internal onlyInitializing {\n    }\n\n    function __ERC20Snapshot_init_unchained() internal onlyInitializing {\n    }\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\n    // https://github.com/Giveth/minime/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\n\n    using ArraysUpgradeable for uint256[];\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\n    // Snapshot struct, but that would impede usage of functions that work on an array.\n    struct Snapshots {\n        uint256[] ids;\n        uint256[] values;\n    }\n\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\n    Snapshots private _totalSupplySnapshots;\n\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\n    CountersUpgradeable.Counter private _currentSnapshotId;\n\n    /**\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\n     */\n    event Snapshot(uint256 id);\n\n    /**\n     * @dev Creates a new snapshot and returns its snapshot id.\n     *\n     * Emits a {Snapshot} event that contains the same id.\n     *\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\n     *\n     * [WARNING]\n     * ====\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n     * you must consider that it can potentially be used by attackers in two ways.\n     *\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n     * section above.\n     *\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\n     * ====\n     */\n    function _snapshot() internal virtual returns (uint256) {\n        _currentSnapshotId.increment();\n\n        uint256 currentId = _getCurrentSnapshotId();\n        emit Snapshot(currentId);\n        return currentId;\n    }\n\n    /**\n     * @dev Get the current snapshotId\n     */\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\n        return _currentSnapshotId.current();\n    }\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n\n        return snapshotted ? value : balanceOf(account);\n    }\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\n\n        return snapshotted ? value : totalSupply();\n    }\n\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) {\n            // mint\n            _updateAccountSnapshot(to);\n            _updateTotalSupplySnapshot();\n        } else if (to == address(0)) {\n            // burn\n            _updateAccountSnapshot(from);\n            _updateTotalSupplySnapshot();\n        } else {\n            // transfer\n            _updateAccountSnapshot(from);\n            _updateAccountSnapshot(to);\n        }\n    }\n\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\n        require(snapshotId > 0, \"ERC20Snapshot: id is 0\");\n        require(snapshotId <= _getCurrentSnapshotId(), \"ERC20Snapshot: nonexistent id\");\n\n        // When a valid snapshot is queried, there are three possibilities:\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\n        //  to this id is the current one.\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\n        //  requested id, and its value is the one to return.\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\n        //  larger than the requested one.\n        //\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\n        // exactly this.\n\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\n\n        if (index == snapshots.ids.length) {\n            return (false, 0);\n        } else {\n            return (true, snapshots.values[index]);\n        }\n    }\n\n    function _updateAccountSnapshot(address account) private {\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\n    }\n\n    function _updateTotalSupplySnapshot() private {\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\n    }\n\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\n        uint256 currentId = _getCurrentSnapshotId();\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\n            snapshots.ids.push(currentId);\n            snapshots.values.push(currentValue);\n        }\n    }\n\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\n        if (ids.length == 0) {\n            return 0;\n        } else {\n            return ids[ids.length - 1];\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/ArraysUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Arrays.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary ArraysUpgradeable {\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && array[low - 1] == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/interfaces/IERC4626Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20Upgradeable.sol\";\nimport \"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626Upgradeable is IERC20Upgradeable, IERC20MetadataUpgradeable {\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./AddressUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract MulticallUpgradeable is Initializable {\n    function __Multicall_init() internal onlyInitializing {\n    }\n\n    function __Multicall_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = _functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
        }
    },
    "settings": {
        "metadata": {
            "useLiteralContent": true
        },
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ],
                "": [
                    "id",
                    "ast"
                ]
            }
        }
    }
}